
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  A node in an xml tree.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _XML_NODE_CLASS_H_
#define _XML_NODE_CLASS_H_

#include "XmlDom/Predicates.h"

#include <list>
#include <map>
#include <algorithm>


namespace XML {


///////////////////////////////////////////////////////////////////////////////
//
//  The node class.
//
///////////////////////////////////////////////////////////////////////////////

template < class PolicyType > class Node
{
public:

  /////////////////////////////////////////////////////////////////////////////
  //
  //  Useful typedefs.
  //
  /////////////////////////////////////////////////////////////////////////////

  typedef PolicyType Policy;
  typedef typename Policy::String String;
  typedef typename Policy::ErrorPolicy ErrorPolicy;
  typedef typename Policy::MissingPolicy MissingPolicy;
  typedef std::list < Node * > Children;
  typedef std::map < String, String > Attributes;
  typedef typename String::value_type Char;
  typedef typename Children::iterator ChildItr;
  typedef typename Children::const_iterator ConstChildItr;
  typedef typename Children::size_type SizeType;
  typedef XML::Predicates::IthEqualName < String > IthEqualName;


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Default constructor.
  //
  /////////////////////////////////////////////////////////////////////////////

  Node ( const String &name = String(), const String &value = String(), const Attributes &attributes = Attributes() ) :
    _children(),
    _name ( name ),
    _value ( value ),
    _attributes ( attributes ),
    _refCount ( 0 )
  {
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Copy constructor.
  //
  /////////////////////////////////////////////////////////////////////////////

  Node ( const Node &n ) :
    _children   ( n._children ),
    _name       ( n._name ),
    _value      ( n._value ),
    _attributes ( n._attributes ),
    _refCount   ( 0 )
  {
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Assignment.
  //
  /////////////////////////////////////////////////////////////////////////////

  Node &operator = ( const Node &n )
  {
    _children   = n._children;
    _name       = n._name;
    _value      = n._value;
    _attributes = n._attributes;

    // Note: _refCount is unchanged.

    return *this;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Append the new child.
  //
  /////////////////////////////////////////////////////////////////////////////

  void append ( Node *n )
  {
    if ( n )
    {
      _children.push_back ( n );
      n->ref();
    }
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the i'th child node.
  //
  /////////////////////////////////////////////////////////////////////////////

  const Node *child ( SizeType i ) const
  {
    if ( i > _children.size() ) 
      return this->_getMissingChild();

    ConstChildItr it = _children.begin();
    std::advance ( it, i );
    return *i;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the i'th child by name.
  //
  /////////////////////////////////////////////////////////////////////////////

  Node *child ( SizeType i, const String &name ) const
  {
    ConstChildItr it = std::find_if ( this->begin(), this->end(), IthEqualName ( name, i ) );
    return ( it == this->end() ) ? this->_getMissingChild() : *it;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the child node by the given path.
  //
  /////////////////////////////////////////////////////////////////////////////

  Node *child ( const String &path, Char delim ) const
  {
    // Get the child, which may be null.
    Node *node = this->_child ( path, delim );

    // Only return null if we are supposed to.
    return ( node ) ? node : this->_getMissingChild();
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the number of children.
  //
  /////////////////////////////////////////////////////////////////////////////

  SizeType numChildren() const
  {
    return _children.size();
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the number of attributes.
  //
  /////////////////////////////////////////////////////////////////////////////

  unsigned int numAttributes() const
  {
    return _attributes.size();
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the name of this node.
  //
  /////////////////////////////////////////////////////////////////////////////

  const String &name() const
  {
    return _name;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the value, which should be empty if there are children.
  //
  /////////////////////////////////////////////////////////////////////////////

  const String &value() const
  {
    return _value;
  }

  
  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the i'th attribute.
  //
  /////////////////////////////////////////////////////////////////////////////

  String attribute ( unsigned int i ) const
  {
    if ( i >= _attributes.size() )
      return String();
    typename Attributes::iterator itr = _attributes.begin();
    std::advance ( itr, i );
    return *itr;
  }

  
  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the attribute by name.
  //
  /////////////////////////////////////////////////////////////////////////////

  String attribute ( const String &name ) const
  {
    typename Attributes::const_iterator i = _attributes.find ( name );
    return ( _attributes.end() == i ) ? String() : i->second;
  }

  
  /////////////////////////////////////////////////////////////////////////////
  //
  //  Set the attribute. This will add a new attribute of the given attribute 
  //  name does not exist.
  //
  /////////////////////////////////////////////////////////////////////////////

  void attribute ( const String &name, const String &value )
  {
    _attributes[name] = value;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Set the name.
  //
  /////////////////////////////////////////////////////////////////////////////

  void name ( const String &name )
  {
    _name = name;
  }

  
  /////////////////////////////////////////////////////////////////////////////
  //
  //  Set the value.
  //
  /////////////////////////////////////////////////////////////////////////////

  void value ( const String &value )
  {
    _value = value;
  }

  
  /////////////////////////////////////////////////////////////////////////////
  //
  //  Reference this node.
  //
  /////////////////////////////////////////////////////////////////////////////

  void ref()
  {
    ++_refCount;
  }

  
  /////////////////////////////////////////////////////////////////////////////
  //
  //  Unreference this node.
  //
  /////////////////////////////////////////////////////////////////////////////

  void unref()
  {
    ErrorPolicy() ( 3381263621u, _refCount > 0 );

    if ( 0 == ( --_refCount ) )
      delete this;
  }


  /////////////////////////////////////////////////////////////////////////////
  ///
  ///  Return the first iterator.
  ///
  /////////////////////////////////////////////////////////////////////////////

  ChildItr begin()
  {
    return _children.begin();
  }


  /////////////////////////////////////////////////////////////////////////////
  ///
  ///  Return the first iterator.
  ///
  /////////////////////////////////////////////////////////////////////////////

  ConstChildItr begin() const
  {
    return _children.begin();
  }


  /////////////////////////////////////////////////////////////////////////////
  ///
  ///  Return one past the last iterator.
  ///
  /////////////////////////////////////////////////////////////////////////////

  ChildItr end()
  {
    return _children.end();
  }


  /////////////////////////////////////////////////////////////////////////////
  ///
  ///  Return one past the last iterator.
  ///
  /////////////////////////////////////////////////////////////////////////////

  ConstChildItr end() const
  {
    return _children.end();
  }

  
  /////////////////////////////////////////////////////////////////////////////
  //
  //  Accept the visitor.
  //
  /////////////////////////////////////////////////////////////////////////////

  template < class VisitorType > void accept ( VisitorType &visitor )
  {
    // Visit this node.
    visitor ( *this );
  }


protected:


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Destructor.
  //
  /////////////////////////////////////////////////////////////////////////////

  virtual ~Node()
  {
    // Unref all the children.
    for ( ChildItr i = _children.begin(); i != _children.end(); ++i )
      (*i)->unref();
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the child node by the given path.
  //
  /////////////////////////////////////////////////////////////////////////////

  Node *_child ( const String &path, Char delim ) const
  {
    typedef typename String::const_iterator SI;

    // Look for the first name in the path.
    SI last = std::find ( path.begin(), path.end(), delim );

    // Make the name.
    String name ( path.begin(), last );

    // If we're already at the end of the path-string...
    if ( last == path.end() )
    {
      // Get the first child by this name. Do not call name(), we have 
      // to return an invalid node if we didn't find one.
      ConstChildItr it = std::find_if ( this->begin(), this->end(), IthEqualName ( name, 0 ) );
      return ( it == this->end() ) ? 0x0 : *it;
    }

    // Increment now.
    ++last;

    // Loop through the children.
    for ( ConstChildItr i = _children.begin(); i != _children.end(); ++i )
    {
      // Get the child.
      Node *child = *i;

      // Do the names match?
      if ( child->name() == name )
      {
        // Call this function recursively with the rest of the path-string.
        String temp ( last, path.end() );
        child = child->_child ( temp, delim );

        // Did we find it?
        if ( child )
        {
          return child;
        }
      }
    }

    // We didn't find anything.
    return 0x0;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the missing child. Either creates a new node or returns null.
  //
  /////////////////////////////////////////////////////////////////////////////

  Node *_getMissingChild() const
  {
    MissingPolicy m;
    return ( m() ) ? new Node : 0x0;
  }


private:


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Data members.
  //
  /////////////////////////////////////////////////////////////////////////////

  Children _children;
  String _name;
  String _value;
  Attributes _attributes;
  unsigned int _refCount;
};


}; // namespace XML


#endif // _XML_NODE_CLASS_H_
