
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2008, Arizona State University
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//  Authors: Adam Kubach.
//
///////////////////////////////////////////////////////////////////////////////

#include "LibraryPool.h"
#include "Usul/Trace/Trace.h"

#include <iostream>

using namespace Usul::DLL;

///////////////////////////////////////////////////////////////////////////////
//
//  Static data member
//
///////////////////////////////////////////////////////////////////////////////

LibraryPool* LibraryPool::_instance ( 0x0 );


///////////////////////////////////////////////////////////////////////////////
//
//  Get the instance
//
///////////////////////////////////////////////////////////////////////////////

LibraryPool& LibraryPool::instance()
{
  USUL_TRACE_SCOPE_STATIC;
  if ( !_instance )
    _instance = new LibraryPool();
  return *_instance;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
///////////////////////////////////////////////////////////////////////////////

LibraryPool::LibraryPool() :
  _pool(),
  _mutex ( Mutex::create() )
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
///////////////////////////////////////////////////////////////////////////////

LibraryPool::~LibraryPool()
{
  USUL_TRACE_SCOPE;
  delete _mutex; _mutex = 0x0;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Add
//
///////////////////////////////////////////////////////////////////////////////

void LibraryPool::add ( Library *library )
{
  USUL_TRACE_SCOPE;
  Guard guard ( *_mutex );
  
  if ( 0x0 != library )
    _pool.insert ( library );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Clear
//
///////////////////////////////////////////////////////////////////////////////

void LibraryPool::clear ( std::ostream *out )
{
  USUL_TRACE_SCOPE;
  Guard guard ( *_mutex );
  
  if ( 0x0 == out )
  {
    _pool.clear();
    return;
  }
  
  while ( false == _pool.empty() )
  {
    LibrarySet::iterator i ( _pool.begin() );
    (*out) << "Releasing file: " << (*i)->filename() << std::endl;
    _pool.erase ( i );
  }
}
