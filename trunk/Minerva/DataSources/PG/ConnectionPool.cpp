
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2007, Arizona State University
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//  Created by: Adam Kubach
//
///////////////////////////////////////////////////////////////////////////////

#include "Minerva/DataSources/PG/ConnectionPool.h"

using namespace Minerva::DataSources::PG;


///////////////////////////////////////////////////////////////////////////////
//
//  Initalize static data member.
//
///////////////////////////////////////////////////////////////////////////////

ConnectionPool* ConnectionPool::_instance( 0x0 );


///////////////////////////////////////////////////////////////////////////////
//
//  Get the instance.
//
///////////////////////////////////////////////////////////////////////////////

ConnectionPool& ConnectionPool::instance()
{
	if ( 0x0 == _instance )
		_instance = new ConnectionPool;
	return *_instance;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

ConnectionPool::ConnectionPool() : 
	_mutex ( Mutex::create() ),
	_connections(),
	_passwords()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

ConnectionPool::~ConnectionPool()
{
	delete _mutex;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Does the pool contain a connection by this name?
//
///////////////////////////////////////////////////////////////////////////////

bool ConnectionPool::hasConnection ( const std::string& name ) const
{
	Guard guard ( *_mutex );
  Connections::const_iterator iter = _connections.find( name );
  return iter != _connections.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the connection for the given name.
//
///////////////////////////////////////////////////////////////////////////////

Connection* ConnectionPool::getConnection ( const std::string& name )
{
	Guard guard ( *_mutex );
  return _connections[name].get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Add a connection.
//
///////////////////////////////////////////////////////////////////////////////

void ConnectionPool::addConnection ( Connection* connection )
{
	Guard guard ( *_mutex );
  _connections[ connection->name() ] = connection;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Is the password saved for this user and host.
//
///////////////////////////////////////////////////////////////////////////////

bool ConnectionPool::hasPassword ( const std::string& user, const std::string& host ) const
{
	Guard guard ( *_mutex );
	Passwords::const_iterator iter ( _passwords.find ( Passwords::key_type ( user, host ) ) );
	return ( iter != _passwords.end() );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the password saved for this user and host.
//
///////////////////////////////////////////////////////////////////////////////

std::string ConnectionPool::getPassword ( const std::string& user, const std::string& host ) const
{
	Guard guard ( *_mutex );
	Passwords::const_iterator iter ( _passwords.find ( Passwords::key_type ( user, host ) ) );
	return ( iter != _passwords.end() ? iter->second : "" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the password saved for this user and host.
//
///////////////////////////////////////////////////////////////////////////////

void ConnectionPool::setPassword ( const std::string& user, const std::string& host, const std::string& password )
{
	Guard guard ( *_mutex );
	_passwords[Passwords::key_type ( user, host )] = password;
}
