
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  A sequence of vertex primitives.
//
///////////////////////////////////////////////////////////////////////////////

#include "GSG/Core/Precompiled.h"
#include "GSG/Core/PrimitiveSet.h"

using namespace GSG;

GSG_IMPLEMENT_CLONE ( PrimitiveSet );


/////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
/////////////////////////////////////////////////////////////////////////////

PrimitiveSet::PrimitiveSet() : Referenced(), 
  _vp ( 0x0 ),
  _np ( 0x0 ),
  _cp ( 0x0 ),
  _prims(),
  _bound()
{
}


/////////////////////////////////////////////////////////////////////////////
//
//  Copy constructor.
//
/////////////////////////////////////////////////////////////////////////////

PrimitiveSet::PrimitiveSet ( const PrimitiveSet &s ) : Referenced ( s ), 
  _vp ( s._vp ),
  _np ( s._np ),
  _cp ( s._cp ),
  _prims ( s._prims ),
  _bound ( s._bound )
{
  BOOST_MPL_ASSERT_IS_SAME ( size_type, VertexPool::size_type );
  BOOST_MPL_ASSERT_IS_SAME ( size_type, NormalPool::size_type );
  BOOST_MPL_ASSERT_IS_SAME ( size_type, ColorPool::size_type );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
/////////////////////////////////////////////////////////////////////////////

PrimitiveSet::~PrimitiveSet()
{
  // Empty.
}


/////////////////////////////////////////////////////////////////////////////
//
//  Set the vertex indices.
//
/////////////////////////////////////////////////////////////////////////////

void PrimitiveSet::vertices ( VertexPool *vp )
{
  Lock lock ( this );
  _vp = vp;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Set the vertex indices.
//
/////////////////////////////////////////////////////////////////////////////

void PrimitiveSet::normals ( NormalPool *np )
{
  Lock lock ( this );
  _np = np;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Set the vertex indices.
//
/////////////////////////////////////////////////////////////////////////////

void PrimitiveSet::colors  ( ColorPool *cp )
{
  Lock lock ( this );
  _cp = cp;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Get the bounding sphere.
//
/////////////////////////////////////////////////////////////////////////////

const BoundingSphere &PrimitiveSet::boundingSphere() const
{
  return _bound;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Set the bounding sphere.
//
/////////////////////////////////////////////////////////////////////////////

void PrimitiveSet::boundingSphere ( const BoundingSphere &b )
{
  Lock lock ( this );
  _bound = b;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Calculate the bounding sphere.
//
/////////////////////////////////////////////////////////////////////////////

void PrimitiveSet::calculateBoundingSphere()
{
  // Loop through the primitives and grow the bounding sphere.
  BoundingSphere bound;
  for ( Sets::iterator i = _prims.begin(); i != _prims.end(); ++i )
  {
    Primitive::ValidPtr prim ( *i );
    bound.grow ( prim->calculateBoundingSphere ( _vp ) );
  }

  // Set this instance's sphere.
  this->boundingSphere ( bound );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Calculate the bounding sphere.
//
/////////////////////////////////////////////////////////////////////////////

HERE
Snag: need to interpret indices correctly.
Either need a smart iterator or a (template?) function that takes a functor.
This functor will most likely need to call a member function.

void PrimitiveSet::_calculateBoundingSphere ( const Primitive *prim )
{
  // Loop through the vertices and grow the bounding sphere.
  BoundingSphere bound;
  Indices::size_type numVerts ( prim->vertices().size() );
  for ( Indices::size_type i = 0; i < prim->vertices().size(); ++i )
  {
    Primitive::ValidPtr prim ( *i );
    bound.grow ( _pool->value ( i ) );
  }
}
