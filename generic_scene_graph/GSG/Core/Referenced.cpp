
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Reference-counting class.
//
///////////////////////////////////////////////////////////////////////////////

#include "GSG/Core/Precompiled.h"
#include "GSG/Core/Referenced.h"

using namespace GSG;


/////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
/////////////////////////////////////////////////////////////////////////////

Referenced::Referenced() : RootClass(),
  _refCount ( 0 )
{

}


/////////////////////////////////////////////////////////////////////////////
//
//  Copy constructor.
//
/////////////////////////////////////////////////////////////////////////////

Referenced::Referenced ( const Referenced &r ) : RootClass ( r ),
  _refCount ( 0 )
{

}


/////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
/////////////////////////////////////////////////////////////////////////////

Referenced::~Referenced()
{

}


/////////////////////////////////////////////////////////////////////////////
//
//  Reference this instance.
//
/////////////////////////////////////////////////////////////////////////////

void Referenced::ref()
{
  Lock lock ( this );
  ++_refCount;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Unreference this instance.
//
/////////////////////////////////////////////////////////////////////////////

void Referenced::unref ( bool allowDeletion )
{
  Lock lock ( this );
  GSG_ASSERT ( _refCount >= 1 );
  if ( 0 == --_refCount && allowDeletion )
    delete this;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Safely clone the given pointer.
//
/////////////////////////////////////////////////////////////////////////////

Referenced *Referenced::safeClone ( const Referenced *p )
{
  return ( ( p ) ? p->clone() : 0x0 );
}


/////////////////////////////////////////////////////////////////////////////
//
//  This empty stub is just here to support the macros.
//
/////////////////////////////////////////////////////////////////////////////

void Referenced::setFrom ( const Referenced & )
{
}


/////////////////////////////////////////////////////////////////////////////
//
//  Safely reference.
//
/////////////////////////////////////////////////////////////////////////////

void Referenced::safeRef ( Referenced *r )
{
  if ( r )
    r->ref();
}


/////////////////////////////////////////////////////////////////////////////
//
//  Safely unreference.
//
/////////////////////////////////////////////////////////////////////////////

void Referenced::safeUnref ( Referenced *r, bool allowDeletion )
{
  if ( r )
    r->unref ( allowDeletion );
}


/////////////////////////////////////////////////////////////////////////////
//
//  For use with smart pointer classes.
//
/////////////////////////////////////////////////////////////////////////////

namespace GSG
{
  namespace Detail
  {
    void intrusive_ptr_add_ref ( GSG::Referenced *ptr )
    {
      ptr->ref();
    }
    void intrusive_ptr_release ( GSG::Referenced *ptr )
    {
      ptr->unref ( true );
    }
    void ptr_release_no_delete ( GSG::Referenced *ptr )
    {
      ptr->unref ( false );
    }
  };
};
