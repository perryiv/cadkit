
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Error stack.
//
///////////////////////////////////////////////////////////////////////////////

#include "Usul/Errors/Stack.h"
#include "Usul/Errors/Assert.h"
#include "Usul/Threads/Mutex.h"
#include "Usul/Threads/Guard.h"

#include <sstream>

using namespace Usul;
using namespace Usul::Errors;


///////////////////////////////////////////////////////////////////////////////
//
//  Don't want this in the header.
//
///////////////////////////////////////////////////////////////////////////////

typedef Usul::Threads::Guard<Stack::Mutex> Guard;


///////////////////////////////////////////////////////////////////////////////
//
//  Static data member(s).
//
///////////////////////////////////////////////////////////////////////////////

Stack *Stack::_instance ( 0x0 );


///////////////////////////////////////////////////////////////////////////////
//
//  Default constructor.
//
///////////////////////////////////////////////////////////////////////////////

Stack::Stack() : _s(), _m ( Mutex::create() )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Default constructor.
//
///////////////////////////////////////////////////////////////////////////////

Element::Element()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Copy constructor.
//
///////////////////////////////////////////////////////////////////////////////

Element::Element ( const Element &e ) : BaseClass ( e )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Element::Element ( unsigned int id, const std::string &m ) : BaseClass ( id, m )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Stack::~Stack()
{
  delete _m;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Element::~Element()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the one instance.
//
///////////////////////////////////////////////////////////////////////////////

Stack &Stack::instance()
{
  // Guard the creation of the instance. TODO, use double-lock pattern.
  static Mutex *mutex = Mutex::create();
  Guard guard ( *mutex );

  // If no instance yet.
  if ( 0x0 == _instance )
  {
    // Declare new instance.
    _instance = new Stack;
  }

  // Return the instance.
  return *_instance;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Clear the stack.
//
///////////////////////////////////////////////////////////////////////////////

void Stack::clear()
{
  Guard guard ( *_m );
  while ( !_s.empty() )
    _s.pop();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Is it empty?
//
///////////////////////////////////////////////////////////////////////////////

bool Stack::empty() const
{
  Guard guard ( *_m );
  bool result ( _s.empty() );
  return result;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the size.
//
///////////////////////////////////////////////////////////////////////////////

Stack::size_type Stack::size() const
{
  Guard guard ( *_m );
  size_type result ( _s.size() );
  return result;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Push an error.
//
///////////////////////////////////////////////////////////////////////////////

void Stack::push ( unsigned int id, const std::string &message )
{
  Guard guard ( *_m );
  _s.push ( Usul::Errors::Element ( id, message ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Pop the top error.
//
///////////////////////////////////////////////////////////////////////////////

void Stack::pop()
{
  Guard guard ( *_m );
  _s.pop();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the top error.
//
///////////////////////////////////////////////////////////////////////////////

Usul::Errors::Element Stack::top() const
{
  Guard guard ( *_m );
  Element result ( _s.top() );
  return result;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Format the errors into single string.
//
///////////////////////////////////////////////////////////////////////////////

void Stack::format ( std::string &s ) const
{
  Guard guard ( *_m );
  typedef Elements::container_type Container;
  std::ostringstream temp;
  for ( Container::const_iterator i = _s.begin(); i != _s.end(); ++i )
    temp << i->id() << ": " << i->message() << '\n';
  s = temp.str();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Format the errors into single string.
//
///////////////////////////////////////////////////////////////////////////////

std::string Stack::format() const
{
  std::string s;
  this->format ( s );
  return s;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the id.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Element::id() const
{
  return this->first;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the message.
//
///////////////////////////////////////////////////////////////////////////////

const std::string &Element::message() const
{
  return this->second;
}
