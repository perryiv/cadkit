
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2007, Arizona State University
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//  Author: Perry L Miller IV
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Group class.
//
///////////////////////////////////////////////////////////////////////////////

#include "StarSystem/Group.h"
#include "StarSystem/Visitor.h"

#include "Usul/Adaptors/MemberFunction.h"
#include "Usul/Functions/SafeCall.h"
#include "Usul/Trace/Trace.h"

#include "osg/Group"

#include <algorithm>

using namespace StarSystem;

STAR_SYSTEM_IMPLEMENT_NODE_CLASS ( Group );


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
///////////////////////////////////////////////////////////////////////////////

Group::Group() : BaseClass(),
  _nodes()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
///////////////////////////////////////////////////////////////////////////////

Group::~Group()
{
  USUL_TRACE_SCOPE;
  Usul::Functions::safeCall ( Usul::Adaptors::memberFunction ( this, &Group::_destroy ), "2555885310" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destroy
//
///////////////////////////////////////////////////////////////////////////////

void Group::_destroy()
{
  USUL_TRACE_SCOPE;
  _nodes.clear();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Build the scene.
//
///////////////////////////////////////////////////////////////////////////////

osg::Node *Group::buildScene ( const Group::BuildOptions &options, Usul::Interfaces::IUnknown *caller )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );

  osg::ref_ptr<osg::Group> group ( new osg::Group() );

  for ( Nodes::iterator i = _nodes.begin(); i != _nodes.end(); ++i )
  {
    Node::RefPtr &base ( *i );
    if ( true == base.valid() )
    {
      group->addChild ( base->buildScene ( options, caller ) );
    }
  }

  return group.release();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the nodes.
//
///////////////////////////////////////////////////////////////////////////////

void Group::nodes ( Group::Nodes &nodes )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  _nodes = nodes;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the nodes.
//
///////////////////////////////////////////////////////////////////////////////

Group::Nodes &Group::nodes()
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _nodes;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the nodes.
//
///////////////////////////////////////////////////////////////////////////////

const Group::Nodes &Group::nodes() const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _nodes;
}
