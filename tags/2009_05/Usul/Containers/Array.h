
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  An array class that has a standard interface.
//  Inspired by boost::array by Nicolai Josuttis.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _USUL_CONTAINERS_ARRAY_CLASS_H_
#define _USUL_CONTAINERS_ARRAY_CLASS_H_

#include <iterator>


namespace Usul {
namespace Containers {


template < class T, std::size_t N, class ErrorChecker_ > class Array
{
public:

  /////////////////////////////////////////////////////////////////////////////
  //
  //  Typedefs
  //
  /////////////////////////////////////////////////////////////////////////////

  typedef ErrorChecker_                 ErrorChecker;
  typedef T                             value_type;
  typedef T *                           iterator;
  typedef const T *                     const_iterator;
  typedef T &                           reference;
  typedef const T &                     const_reference;
  typedef std::size_t                   size_type;
  typedef std::ptrdiff_t                difference_type;
  typedef Array<T,N,ErrorChecker>       this_type;
  typedef std::reverse_iterator < iterator,       T > reverse_iterator;
  typedef std::reverse_iterator < const_iterator, T > const_reverse_iterator;


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Enumerations
  //
  /////////////////////////////////////////////////////////////////////////////

  enum { Size = N };


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Assignment.
  //
  /////////////////////////////////////////////////////////////////////////////

  template < typename T2 > this_type &operator = ( const Array<T2,N,ErrorChecker> &a )
  {
    std::copy ( a.begin(), a.end(), this->begin() );
    return *this;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Is it empty?
  //
  /////////////////////////////////////////////////////////////////////////////

  static bool empty()
  {
    return ( 0 == N );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the size of the vector.
  //
  /////////////////////////////////////////////////////////////////////////////

  static size_type size()
  {
    return N;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the maximum size of the vector.
  //
  /////////////////////////////////////////////////////////////////////////////

  static size_type max_size()
  {
    return N;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the capacity of the vector.
  //
  /////////////////////////////////////////////////////////////////////////////

  static size_type capacity()
  {
    return N;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Get the maximum capacity of the vector.
  //
  /////////////////////////////////////////////////////////////////////////////

  static size_type max_capacity()
  {
    return N;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Iterators.
  //
  /////////////////////////////////////////////////////////////////////////////

  iterator begin()
  {
    return _a;
  }
  const_iterator begin() const
  {
    return _a;
  }
  iterator end()
  {
    return _a + N;
  }
  const_iterator end() const
  {
    return _a + N;
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Reverse iterators.
  //
  /////////////////////////////////////////////////////////////////////////////

  iterator rbegin()
  {
    return reverse_iterator ( this->end() );
  }
  const_iterator rbegin() const
  {
    return const_reverse_iterator ( this->end() );
  }
  iterator rend()
  {
    return reverse_iterator ( this->begin() );
  }
  const_iterator rend() const
  {
    return const_reverse_iterator ( this->begin() );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Random access.
  //
  /////////////////////////////////////////////////////////////////////////////

  reference at ( size_type i )
  {
    ErrorChecker ( __FILE__, __LINE__, i < N );
    return _a[i];
  }
  const_reference at ( size_type i ) const
  {
    ErrorChecker ( __FILE__, __LINE__, i < N );
    return _a[i];
  }
  reference at ( difference_type i )
  {
    ErrorChecker ( __FILE__, __LINE__, i >= 0 );
    ErrorChecker ( __FILE__, __LINE__, i < static_cast < difference_type > ( N ) );
    return _a[i];
  }
  const_reference at ( difference_type i ) const
  {
    ErrorChecker ( __FILE__, __LINE__, i >= 0 );
    ErrorChecker ( __FILE__, __LINE__, i < static_cast < difference_type > ( N ) );
    return _a[i];
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Array syntax.
  //
  /////////////////////////////////////////////////////////////////////////////

  reference operator [] ( size_type i )
  {
    return this->at ( i );
  }
  const_reference operator [] ( size_type i ) const
  {
    return this->at ( i );
  }
  reference operator [] ( difference_type i )
  {
    return this->at ( i );
  }
  const_reference operator [] ( difference_type i ) const
  {
    return this->at ( i );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Access first element.
  //
  /////////////////////////////////////////////////////////////////////////////

  reference front()
  {
    return this->at ( 0 );
  }
  const_reference front() const
  {
    return this->at ( 0 );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Access last element.
  //
  /////////////////////////////////////////////////////////////////////////////

  reference back()
  {
    return this->at ( N - 1 );
  }
  const_reference back() const
  {
    return this->at ( N - 1 );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  See if the vectors are equal.
  //
  /////////////////////////////////////////////////////////////////////////////

  bool equal ( const this_type &a ) const
  {
    return ( std::equal ( this->begin(), this->end(), a.begin() ) );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Assign this vector.
  //
  /////////////////////////////////////////////////////////////////////////////

  void assign ( const value_type &value )
  {
    std::fill_n ( this->begin(), N, value );
  }


  /////////////////////////////////////////////////////////////////////////////
  //
  //  Equality predicates for troublesome nested containers.
  //
  /////////////////////////////////////////////////////////////////////////////

  struct IsEqual : public std::binary_function < value_type, value_type, bool >
  {
    bool operator () ( const value_type &a, const value_type &b )
    {
      return ( a.equal ( b ) );
    }
  };

private:

  T _a[N];
};


} // namespace Containers
} // namespace Usul


///////////////////////////////////////////////////////////////////////////////
//
//  Equality operator. Cannot be a member.
//
///////////////////////////////////////////////////////////////////////////////

template < class S, class E > inline bool operator == 
  ( const Usul::Containers::Array<S,E> &c1, const Usul::Containers::Array<S,E> &c2 )
{
  return c1.equal ( c2 );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Inequality operator. Cannot be a member.
//
///////////////////////////////////////////////////////////////////////////////

template < class S, class E > inline bool operator != 
  ( const Usul::Containers::Array<S,E> &c1, const Usul::Containers::Array<S,E> &c2 )
{
  return !( c1.equal ( c2 ) );
}


#endif // _USUL_CONTAINERS_ARRAY_CLASS_H_
