
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2007, Arizona State University
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//  Author: Adam Kubach
//
///////////////////////////////////////////////////////////////////////////////

#include "Helios/Plugins/VolumeModel/ReaderWriterFactory.h"

///////////////////////////////////////////////////////////////////////////////
//
//  Initialize singleton pointer.
//
///////////////////////////////////////////////////////////////////////////////

ReaderWriterFactory* ReaderWriterFactory::_instance ( 0x0 );


///////////////////////////////////////////////////////////////////////////////
//
//  Get the instance.
//
///////////////////////////////////////////////////////////////////////////////

ReaderWriterFactory& ReaderWriterFactory::instance()
{
  if ( 0x0 == _instance )
    _instance = new ReaderWriterFactory;
  return *_instance;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

ReaderWriterFactory::ReaderWriterFactory () : 
_mutex ( new Mutex ),
_readerWriters ()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

ReaderWriterFactory::~ReaderWriterFactory ()
{
  delete _mutex;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get all the filters that the registered reader/writers can open.
//
///////////////////////////////////////////////////////////////////////////////

//ReaderWriterFactory::Filters ReaderWriterFactory::filtersOpen() const
//{
//  Filters filters;
//
//  Guard guard ( this->mutex() );
//  for ( ReaderWriters::const_iterator iter = _readerWriters.begin(); iter != _readerWriters.end(); ++iter )
//  {
//    ReaderWriterPtr rw ( *iter );
//    if ( rw.valid () )
//      std::copy ( filters.begin(), filters.end(), std::back_inserter ( rw->filtersOpen () ) );
//  }
//
//  return filters;
//}


///////////////////////////////////////////////////////////////////////////////
//
//  Is there a reader/writer that can open given file.
//
///////////////////////////////////////////////////////////////////////////////

//bool ReaderWriterFactory::canOpen ( const std::string &file ) const
//{
//  Guard guard ( this->mutex() );
//  for ( ReaderWriters::const_iterator iter = _readerWriters.begin(); iter != _readerWriters.end(); ++iter )
//  {
//    ReaderWriterPtr rw ( *iter );
//    if ( rw.valid () && rw->canOpen ( file ) )
//      return true;
//  }
//
//  return false;
//}


///////////////////////////////////////////////////////////////////////////////
//
//  Register a reader/writer.
//
///////////////////////////////////////////////////////////////////////////////

void ReaderWriterFactory::add ( IReaderWriter* rw )
{
  Guard guard ( this->mutex() );
  _readerWriters.push_back ( rw );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Create a reader/writer.
//
///////////////////////////////////////////////////////////////////////////////

IReaderWriter* ReaderWriterFactory::create ( const std::string& file )
{
  Guard guard ( this->mutex() );
  for ( ReaderWriters::const_iterator iter = _readerWriters.begin(); iter != _readerWriters.end(); ++iter )
  {
    ReaderWriterPtr rw ( *iter );
    if ( rw.valid () && rw->handle ( file ) )
      return rw->clone();
  }

  return 0x0;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the mutex.
//
///////////////////////////////////////////////////////////////////////////////

ReaderWriterFactory::Mutex & ReaderWriterFactory::mutex() const
{
  return *_mutex;
}
