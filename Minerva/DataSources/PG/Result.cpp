
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2009, Adam Kubach
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

#include "Minerva/DataSources/PG/Result.h"
#include "Minerva/DataSources/BinaryString.h"

#include "Usul/Adaptors/Bind.h"
#include "Usul/Convert/Convert.h"
#include "Usul/Scope/Caller.h"

#include "libpq-fe.h"

using namespace Minerva::DataSources::PG;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Result::Result ( PGresult *result ) : BaseClass(),
  _result ( result ),
  _currentRow ( -1 )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Result::~Result()
{
  ::PQclear ( _result );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column name for the given column index.
//
///////////////////////////////////////////////////////////////////////////////

std::string Result::columnName ( unsigned int which ) const
{
  return ::PQfname ( _result, which );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column index for the given name.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Result::columnIndex ( const std::string& columnName ) const
{
  int column ( ::PQfnumber ( _result, columnName.c_str() ) );
  if ( column < 0 )
  {
    throw std::runtime_error ( "Error 3368074323: Could not find column named: " + columnName );
  }
  
  return column;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the number of rows in the result.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Result::numRows() const
{
  return ::PQntuples ( _result );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the number of columns.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Result::numColumns() const
{
  return ::PQnfields ( _result );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the next row.  Will return null if there are no more rows.
//
///////////////////////////////////////////////////////////////////////////////

bool Result::prepareNextRow()
{
  ++_currentRow;
  
  if ( _currentRow == this->numRows() )
    return false;
  
  return true;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the value of the row and column.
//
///////////////////////////////////////////////////////////////////////////////

char* Result::_getValue ( unsigned int row, unsigned int column ) const
{
  return ::PQgetvalue ( _result, row, column );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the length value of the row and column.
//
///////////////////////////////////////////////////////////////////////////////

int Result::_getLength ( unsigned int row, unsigned int column ) const
{
  return ::PQgetlength ( _result, row, column );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Is the row and column null?
//
///////////////////////////////////////////////////////////////////////////////

bool Result::_isNull ( unsigned int row, unsigned int column ) const
{
  return 1 == ::PQgetisnull ( _result, row, column );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Is the column null?
//
///////////////////////////////////////////////////////////////////////////////

bool Result::isNull ( const std::string& columnName ) const
{
  return this->isNull ( this->columnIndex ( columnName ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Is the column null?
//
///////////////////////////////////////////////////////////////////////////////

bool Result::isNull ( unsigned int column ) const
{
  return this->_isNull ( _currentRow, column );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as a string.
//
///////////////////////////////////////////////////////////////////////////////

std::string Result::asString ( const std::string& columnName ) const
{
  return this->asString ( this->columnIndex ( columnName ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as a string.
//
///////////////////////////////////////////////////////////////////////////////

std::string Result::asString ( unsigned int column ) const
{
  char *value ( this->_getValue ( _currentRow, column ) );
  int length ( this->_getLength ( _currentRow, column ) );
  
  std::string result;
  result.assign ( value, length );
  return result;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as a bool.
//
///////////////////////////////////////////////////////////////////////////////

bool Result::asBool ( const std::string& columnName ) const
{
  return this->asBool ( this->columnIndex ( columnName ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as a bool.
//
///////////////////////////////////////////////////////////////////////////////

bool Result::asBool ( unsigned int which ) const
{
  return Usul::Convert::Type<std::string,bool>::convert ( this->asString ( which ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as an unsigned int.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Result::asUInt ( const std::string& columnName ) const
{
  return this->asUInt ( this->columnIndex ( columnName ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as an unsigned int.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Result::asUInt ( unsigned int which ) const
{
  return Usul::Convert::Type<std::string,unsigned int>::convert ( this->asString ( which ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as an int.
//
///////////////////////////////////////////////////////////////////////////////

int Result::asInt ( const std::string& columnName ) const
{
  return this->asInt ( this->columnIndex ( columnName ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as an int.
//
///////////////////////////////////////////////////////////////////////////////

int Result::asInt ( unsigned int which ) const
{
  return Usul::Convert::Type<std::string,int>::convert ( this->asString ( which ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as a float.
//
///////////////////////////////////////////////////////////////////////////////

float Result::asFloat ( const std::string& columnName ) const
{
  return this->asFloat ( this->columnIndex ( columnName ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as a float.
//
///////////////////////////////////////////////////////////////////////////////

float Result::asFloat ( unsigned int which ) const
{
  return Usul::Convert::Type<std::string,float>::convert ( this->asString ( which ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as a double.
//
///////////////////////////////////////////////////////////////////////////////

double Result::asDouble ( const std::string& columnName ) const
{
  return this->asDouble ( this->columnIndex ( columnName ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as a double.
//
///////////////////////////////////////////////////////////////////////////////

double Result::asDouble ( unsigned int which ) const
{
  return Usul::Convert::Type<std::string,double>::convert ( this->asString ( which ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as a blob.
//
///////////////////////////////////////////////////////////////////////////////

Result::BinaryString* Result::asBlob ( const std::string& columnName ) const
{
  return this->asBlob ( this->columnIndex ( columnName ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the column as a blob.
//
///////////////////////////////////////////////////////////////////////////////

Result::BinaryString* Result::asBlob ( unsigned int column ) const
{
  unsigned char *bytes ( reinterpret_cast<unsigned char*> ( this->_getValue ( _currentRow, column ) ) );
  size_t length ( 0 );
  
  unsigned char * buffer ( ::PQunescapeBytea ( bytes, &length ) );
  Usul::Scope::Caller::RefPtr freeBuffer ( Usul::Scope::makeCaller ( Usul::Adaptors::bind1 ( buffer, ::PQfreemem ) ) );
  
  BinaryString::RefPtr blob ( new BinaryString ( buffer, length ) );  
  return blob.release();
}
