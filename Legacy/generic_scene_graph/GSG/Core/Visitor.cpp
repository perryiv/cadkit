
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 4004, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Base class for all scene graph visitors.
//
///////////////////////////////////////////////////////////////////////////////

#include "GSG/Core/Precompiled.h"
#include "GSG/Core/Visitor.h"
#include "GSG/Core/Group.h"
#include "GSG/Core/Path.h"

using namespace GSG;


/////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
/////////////////////////////////////////////////////////////////////////////

Visitor::Visitor() : Referenced(),
  _viewport(),
  _path ( new Path ),
  _preVisitCB ( 0x0 ),
  _postVisitCB ( 0x0 )
{
  ErrorChecker ( 0x0 != _path );
  _path->ref();
}


/////////////////////////////////////////////////////////////////////////////
//
//  Copy constructor.
//
/////////////////////////////////////////////////////////////////////////////

Visitor::Visitor ( const Visitor &v ) : Referenced ( v ),
  _viewport    ( v._viewport ),
  _path        ( v._path->clonePath() ),
  _preVisitCB  ( dynamic_cast < Callback * > ( Referenced::safeClone ( v._preVisitCB.get() ) ) ),
  _postVisitCB ( dynamic_cast < Callback * > ( Referenced::safeClone ( v._postVisitCB.get() ) ) )
{
  ErrorChecker ( 0x0 != _path );
  ErrorChecker ( _preVisitCB.valid() );
  ErrorChecker ( _postVisitCB.valid() );

  _path->ref();
}


/////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
/////////////////////////////////////////////////////////////////////////////

Visitor::~Visitor()
{
  _path->unref();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor for callback class.
//
///////////////////////////////////////////////////////////////////////////////

Visitor::Callback::~Callback()
{
}


/////////////////////////////////////////////////////////////////////////////
//
//  Declare the empty visit functions. I am not yet sure if these will 
//  prove to be necessary.
//
/////////////////////////////////////////////////////////////////////////////

GSG_DEFINE_EMPTY_VISIT_NODE_FUNCTIONS ( Visitor );
GSG_DEFINE_EMPTY_VISIT_ELEMENT_FUNCTIONS ( Visitor );


/////////////////////////////////////////////////////////////////////////////
//
//  Push the node.
//
/////////////////////////////////////////////////////////////////////////////

void Visitor::_pushNode ( Node *n )
{
  Lock lock ( this );
  _path->push ( n );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Pop the node.
//
/////////////////////////////////////////////////////////////////////////////

void Visitor::_popNode()
{
  Lock lock ( this );
  _path->pop();
}


/////////////////////////////////////////////////////////////////////////////
//
//  Get the visited callback.
//
/////////////////////////////////////////////////////////////////////////////

const Visitor::Callback *Visitor::preVisitCallback() const
{
  return _preVisitCB.get();
}


/////////////////////////////////////////////////////////////////////////////
//
//  Get the visited callback.
//
/////////////////////////////////////////////////////////////////////////////

Visitor::Callback *Visitor::preVisitCallback()
{
  return _preVisitCB.get();
}


/////////////////////////////////////////////////////////////////////////////
//
//  Set the visited callback.
//
/////////////////////////////////////////////////////////////////////////////

void Visitor::preVisitCallback ( Visitor::Callback *cb )
{
  Lock lock ( this );
  _preVisitCB = cb;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Get the visited callback.
//
/////////////////////////////////////////////////////////////////////////////

const Visitor::Callback *Visitor::postVisitCallback() const
{
  return _postVisitCB.get();
}


/////////////////////////////////////////////////////////////////////////////
//
//  Get the visited callback.
//
/////////////////////////////////////////////////////////////////////////////

Visitor::Callback *Visitor::postVisitCallback()
{
  return _postVisitCB.get();
}


/////////////////////////////////////////////////////////////////////////////
//
//  Set the visited callback.
//
/////////////////////////////////////////////////////////////////////////////

void Visitor::postVisitCallback ( Visitor::Callback *cb )
{
  Lock lock ( this );
  _postVisitCB = cb;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Call the callbacks if there are any.
//
/////////////////////////////////////////////////////////////////////////////

void Visitor::_preVisit ( Node &n )
{
  if ( _preVisitCB.valid() )
    (*_preVisitCB) ( *this, n );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Call the callbacks if there are any.
//
/////////////////////////////////////////////////////////////////////////////

void Visitor::_postVisit ( Node &n )
{
  if ( _postVisitCB.valid() )
    (*_postVisitCB) ( *this, n );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Traverse the scene.
//
/////////////////////////////////////////////////////////////////////////////

void Visitor::traverse ( Node &scene )
{
  this->_preTraverse ( scene );
  this->_traverse ( scene );
  this->_postTraverse ( scene );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Called before the scene is traversed.
//
/////////////////////////////////////////////////////////////////////////////

void Visitor::_preTraverse ( Node &scene )
{
}


/////////////////////////////////////////////////////////////////////////////
//
//  Traverse the scene.
//
/////////////////////////////////////////////////////////////////////////////

void Visitor::_traverse ( Node &scene )
{
  scene._accept ( *this );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Traverse the group.
//
/////////////////////////////////////////////////////////////////////////////

void Visitor::_traverse ( Group &g )
{
  for ( Group::iterator i = g.begin(); i != g.end(); ++i )
    this->_traverse ( *(*i) );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Called after the scene is traversed.
//
/////////////////////////////////////////////////////////////////////////////

void Visitor::_postTraverse ( Node &scene )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the viewport.
//
///////////////////////////////////////////////////////////////////////////////

void Visitor::viewport ( const Viewport &viewport )
{
  Lock lock ( this );
  _viewport = viewport;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the viewport.
//
///////////////////////////////////////////////////////////////////////////////

const Viewport &Visitor::viewport() const
{
  return _viewport;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Reset the internal state.
//
///////////////////////////////////////////////////////////////////////////////

void Visitor::reset()
{
}
