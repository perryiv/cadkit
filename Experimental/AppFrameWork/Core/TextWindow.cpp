
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Displays text.
//
///////////////////////////////////////////////////////////////////////////////

#include "AppFrameWork/Core/TextWindow.h"
#include "AppFrameWork/Core/BaseVisitor.h"

using namespace AFW::Core;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

TextWindow::TextWindow() : BaseClass(),
  _lines    (),
  _maxLines ( 1000 )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

TextWindow::~TextWindow()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Make sure there is one line.
//
///////////////////////////////////////////////////////////////////////////////

void TextWindow::_oneLineMin()
{
  if ( _lines.empty() )
    _lines.push_back ( "" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Make sure we do not have too many.
//
///////////////////////////////////////////////////////////////////////////////

void TextWindow::_keepUnderMax()
{
  while ( _lines.size() > this->maxLines() )
    _lines.pop_front();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append the value.
//
///////////////////////////////////////////////////////////////////////////////

void TextWindow::append ( const std::string &s )
{
  if ( false == s.empty() )
  {
    this->_oneLineMin();
    _lines.back() += s;
    this->_keepUnderMax();
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append the value.
//
///////////////////////////////////////////////////////////////////////////////

void TextWindow::append ( const char *s )
{
  if ( s )
  {
    this->_oneLineMin();
    _lines.back() += std::string ( s );
    this->_keepUnderMax();
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append the value.
//
///////////////////////////////////////////////////////////////////////////////

void TextWindow::append ( TextWindow::Flusher f )
{
  if ( TextWindow::ENDL == f )
  {
    this->_oneLineMin();
    _lines.push_back ( "" );
    this->_keepUnderMax();
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the max lines.
//
///////////////////////////////////////////////////////////////////////////////

void TextWindow::maxLines ( unsigned int m )
{
  _maxLines = m;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the max lines.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int TextWindow::maxLines() const
{
  return _maxLines;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators.
//
///////////////////////////////////////////////////////////////////////////////

TextWindow::ConstIterator TextWindow::begin() const
{
  return _lines.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators.
//
///////////////////////////////////////////////////////////////////////////////

TextWindow::ConstIterator TextWindow::end() const
{
  return _lines.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Accept the visitor.
//
///////////////////////////////////////////////////////////////////////////////

void TextWindow::accept ( AFW::Core::BaseVisitor *v )
{
  if ( v )
    v->visit ( this );
}
