
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Mutex classes.
//
///////////////////////////////////////////////////////////////////////////////

#include "Usul/Threads/Mutex.h"
#include "Usul/Trace/Trace.h"
#include "Usul/Errors/Assert.h"

using namespace Usul::Threads;


///////////////////////////////////////////////////////////////////////////////
//
//  Note: I could initialize this to Usul::Threads::newMutex but then the 
//  client may create some single-threaded mutexes accidentally in a 
//  multi-threaded program. The safest thing is to force the client to set 
//  it, even if it comes at the expense of convenience.
//
///////////////////////////////////////////////////////////////////////////////

Mutex::CreateFunction *Mutex::_fun = 0x0;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Mutex::Mutex()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Mutex::~Mutex()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Create the mutex.
//
///////////////////////////////////////////////////////////////////////////////

Mutex *Mutex::create()
{
  USUL_TRACE_SCOPE_STATIC;
  USUL_ASSERT ( _fun ); // The client needs to set this.
  return (*_fun)();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the create-function. Return the previous one.
//  Note: this functions is not thread-safe!
//
///////////////////////////////////////////////////////////////////////////////

Mutex::CreateFunction *Mutex::createFunction ( Mutex::CreateFunction *fun )
{
  USUL_TRACE_SCOPE_STATIC;
  CreateFunction *original = _fun;
  _fun = fun;
  return original;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the create-function.
//
///////////////////////////////////////////////////////////////////////////////

Mutex::CreateFunction *Mutex::createFunction()
{
  USUL_TRACE_SCOPE_STATIC;
  return _fun;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

SingleThreadedMutex::SingleThreadedMutex()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

SingleThreadedMutex::~SingleThreadedMutex()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Lock the mutex.
//
///////////////////////////////////////////////////////////////////////////////

void SingleThreadedMutex::lock()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Unlock the mutex.
//
///////////////////////////////////////////////////////////////////////////////

void SingleThreadedMutex::unlock()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Creation function.
//
///////////////////////////////////////////////////////////////////////////////

namespace Usul
{
  namespace Threads
  {
    Mutex *newSingleThreadedMutexStub()
    {
      USUL_TRACE_SCOPE_STATIC;
      return new SingleThreadedMutex();
    }
  };
};
