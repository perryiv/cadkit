
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, John K. Grant.
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Menu class.
//
///////////////////////////////////////////////////////////////////////////////

#include "MenuKit/Menu.h"
#include "MenuKit/Button.h"
#include "MenuKit/Visitor.h"
#include "MenuKit/Errors.h"
#include "MenuKit/Separator.h"

#include <algorithm>

using namespace MenuKit;


///////////////////////////////////////////////////////////////////////////////
//
//  Default constructor.
//
///////////////////////////////////////////////////////////////////////////////

Menu::Menu(): BaseClass(), 
  _text   (),
  _items  (), 
  _layout ( VERTICAL )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Menu::Menu ( const std::string &name, Layout layout ) :
  BaseClass ( ),
  _text   ( name ),
  _items  (), 
  _layout ( layout )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Copy constructor.
//
///////////////////////////////////////////////////////////////////////////////

Menu::Menu ( const Menu &m ): BaseClass ( m ),
  _text   ( m._text ),
  _items  ( m._items ), 
  _layout ( m._layout )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Menu::~Menu()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Assignment.
//
///////////////////////////////////////////////////////////////////////////////

Menu& Menu::operator = ( const Menu &m )
{
  BaseClass::operator = ( m );
  _text   = m._text;
  _items  = m._items;
  _layout = m._layout;

  return (*this);
}


///////////////////////////////////////////////////////////////////////////////
//
//  Clear the menu.
//
///////////////////////////////////////////////////////////////////////////////

void Menu::clear ()
{
  Guard guard ( this->mutex () );
  _items.clear ();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append the item.
//
///////////////////////////////////////////////////////////////////////////////

void Menu::append ( Item *item )
{
  if ( 0x0 != item )
  {
    item->_setParent ( this );
    _items.push_back ( item );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Prepend the item.
//
///////////////////////////////////////////////////////////////////////////////

void Menu::prepend ( Item *item )
{
  if ( 0x0 != item )
  {
    item->_setParent ( this );
    _items.insert ( _items.begin(), item );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Insert the item.
//
///////////////////////////////////////////////////////////////////////////////

void Menu::insert ( iterator iter, Item *item )
{
  if ( 0x0 != item )
  {
    item->_setParent ( this );
    _items.insert ( iter, item );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Accept the visitor.
//
///////////////////////////////////////////////////////////////////////////////

void Menu::accept ( Visitor &v )
{
  v.apply ( *this );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Traverse the tree.
//
///////////////////////////////////////////////////////////////////////////////

void Menu::traverse ( Visitor &v )
{
  switch( v.mode() )
  {
  case Visitor::NONE: {} break;
  case Visitor::ALL:
    {
      for ( Menu::iterator iter = _items.begin(); iter != _items.end(); ++iter )
        (*iter)->accept ( v );
    } break;
  case Visitor::EXPANDED:
  default:
    {
      if( this->expanded() )
      {
        for ( Menu::iterator iter = _items.begin(); iter != _items.end(); ++iter )
          (*iter)->accept ( v );
      }
    } break;
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Add a separator to the end.
//
///////////////////////////////////////////////////////////////////////////////

void Menu::addSeparator ()
{
  this->append ( new MenuKit::Separator );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Predicate to find menu.
//
///////////////////////////////////////////////////////////////////////////////

namespace Detail
{
  struct FindMenu
  {
    FindMenu ( const std::string& name ) : _name ( name )
    {
    }

    template < class T >
    bool operator () ( const T& t ) const
    {
      if ( Menu* m = dynamic_cast < Menu* > ( t.get() ) )
        return ( _name == m->text () );
      return false;
    }

  private:
    std::string _name;
  };
}


///////////////////////////////////////////////////////////////////////////////
//
//  Find the menu. Create it if we should.
//
///////////////////////////////////////////////////////////////////////////////

Menu* Menu::find ( const std::string& name, bool create )
{
  Guard guard ( this->mutex () );

  // Try and find a item with the name.
  iterator iter = std::find_if ( _items.begin (), _items.end(), Detail::FindMenu ( name ) );
  if ( _items.end() != iter )
  {
    return dynamic_cast < Menu* > ( iter->get() );
  }

  // Initialize.
  Menu::RefPtr menu ( 0x0 );

  // If we get to here then create one if we should.
  if ( true == create )
  {
    menu = new Menu;
    menu->text ( name );
    this->append ( menu );
  }

  // Return menu (which may be null).
  return menu.get();
}
