
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2007, Arizona State University
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//  Author: Perry L Miller IV
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Group class.
//
///////////////////////////////////////////////////////////////////////////////

#include "StarSystem/Group.h"
#include "StarSystem/Visitor.h"

#include "Usul/Adaptors/MemberFunction.h"
#include "Usul/Factory/RegisterCreator.h"
#include "Usul/Functions/SafeCall.h"
#include "Usul/Trace/Trace.h"

#include "osg/Group"

#include <algorithm>

using namespace StarSystem;

USUL_FACTORY_REGISTER_CREATOR ( Group );
STAR_SYSTEM_IMPLEMENT_NODE_CLASS ( Group );


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
///////////////////////////////////////////////////////////////////////////////

Group::Group() : BaseClass(),
  _nodes()
{
  USUL_TRACE_SCOPE;
  this->_addMember ( "nodes", _nodes );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
///////////////////////////////////////////////////////////////////////////////

Group::~Group()
{
  USUL_TRACE_SCOPE;
  Usul::Functions::safeCall ( Usul::Adaptors::memberFunction ( this, &Group::_destroy ), "2555885310" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destroy
//
///////////////////////////////////////////////////////////////////////////////

void Group::_destroy()
{
  USUL_TRACE_SCOPE;
  _nodes.clear();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the nodes.
//
///////////////////////////////////////////////////////////////////////////////

void Group::nodes ( Group::Nodes &nodes )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  _nodes = nodes;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the nodes.
//
///////////////////////////////////////////////////////////////////////////////

Group::Nodes &Group::nodes()
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _nodes;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the nodes.
//
///////////////////////////////////////////////////////////////////////////////

const Group::Nodes &Group::nodes() const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _nodes;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Is the group empty?
//
///////////////////////////////////////////////////////////////////////////////

bool Group::empty() const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _nodes.empty();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Add a node.
//
///////////////////////////////////////////////////////////////////////////////

void Group::add ( Node *node )
{
  USUL_TRACE_SCOPE;

  if ( 0x0 != node )
  {
    Guard guard ( this->mutex() );
    _nodes.push_back ( node );
  }
}
