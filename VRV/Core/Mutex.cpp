
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Mutex classes.
//
///////////////////////////////////////////////////////////////////////////////

#include "Precompiled.h"
#include "Mutex.h"
#include "Exceptions.h"

#include "Usul/Exceptions/Thrower.h"
#include "Usul/Threads/ThreadId.h"

#include "vpr/Thread/Thread.h"

using namespace VRV;
using namespace VRV::Threads;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Mutex::Mutex() : _mutex(), _threadId ( 0 )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Mutex::~Mutex()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Check the state of the mutex,
//
///////////////////////////////////////////////////////////////////////////////

void Mutex::_check()
{
  // See if the mutex is locked.
  if ( _mutex.test() )
  {
    // See if this thread has the lock.
    if ( Usul::Threads::currentThreadId() == _threadId )
    {
      // Bad news.
      Usul::Exceptions::Thrower<VRV::Exceptions::RecursiveMutexLock>
        ( "Error 3349859149, attempting to recursively lock a mutex" );
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Lock the mutex.
//
///////////////////////////////////////////////////////////////////////////////

void Mutex::lock()
{
  this->_check();
  _mutex.acquire();
  _threadId = Usul::Threads::currentThreadId(); // Note: main() thread returns null here.
}


///////////////////////////////////////////////////////////////////////////////
//
//  Unlock the mutex.
//
///////////////////////////////////////////////////////////////////////////////

void Mutex::unlock()
{
  _mutex.release();
  _threadId = 0;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Creation function.
//
///////////////////////////////////////////////////////////////////////////////

namespace VRV
{
  namespace Threads
  {
    Usul::Threads::Mutex *newMutex()
    {
      return new Mutex();
    }
  };
};
