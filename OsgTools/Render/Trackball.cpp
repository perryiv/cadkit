
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Trackball manipulator.
//
///////////////////////////////////////////////////////////////////////////////

#include "OsgTools/Render/Trackball.h"
#include "Usul/Registry/Constants.h"

#include "Usul/Shared/Preferences.h"

#include "osg/Quat"

#include <iostream>

using namespace OsgTools::Render;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Trackball::Trackball() : BaseClass()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Copy constructor.
//
///////////////////////////////////////////////////////////////////////////////

Trackball::Trackball ( const Trackball &copy, const osg::CopyOp &options ) : BaseClass()
{
  this->center   ( copy.center() );
  this->distance ( copy.distance() );
  this->rotation ( copy.rotation() );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Trackball::~Trackball()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Calculate the matrix for the manipulator.
//
///////////////////////////////////////////////////////////////////////////////

osg::Matrixd Trackball::matrix ( const osg::Vec3d &center, const osg::Quat &rotation, double distance )
{
  osg::Matrixd TC ( osg::Matrixd::translate ( -center ) );
  osg::Matrixd IR ( osg::Matrixd::rotate ( rotation.inverse() ) );
  osg::Matrixd TD ( osg::Matrixd::translate ( 0, 0, -distance ) );
  osg::Matrixd M ( TC * IR * TD );
  //std::cout << "Center = " << center[0] << ' ' << center[1] << ' ' << center[2] << ", Distance = " << distance << std::endl;
  return M;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the inverse matrix of the manipulator. Does the same thing as the
//  base class's version, but I think this is easier to follow.
//
///////////////////////////////////////////////////////////////////////////////

osg::Matrixd Trackball::getInverseMatrix() const
{
  return Trackball::matrix ( this->center(), this->rotation(), this->distance() );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Move the camera to the default position. Not sure if checking the scene
//  is important. Keeping this because it is easier to debug this way.
//
///////////////////////////////////////////////////////////////////////////////

void Trackball::home ( const osgGA::GUIEventAdapter &ea, osgGA::GUIActionAdapter &aa )
{
  // Handle no scene.
  if ( 0x0 == this->getNode() )
    return;

  // Call the base class's function.
  BaseClass::home ( ea, aa );

  // The base class uses a rotated coordinate system. Undo that.
  this->rotation ( osg::Quat ( 0, 0, 0, 1 ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Handle events.
//
///////////////////////////////////////////////////////////////////////////////

bool Trackball::handle ( const osgGA::GUIEventAdapter &ea, osgGA::GUIActionAdapter &aa )
{
  // Update the model's scale.
  this->modelScale ( ( 0x0 != this->getNode() ) ? this->getNode()->getBound().radius() : this->modelScale() );

  // If we released the mouse...
  if ( osgGA::GUIEventAdapter::RELEASE == ea.getEventType() )
  {
    // If we are not allowed to spin...
    if ( false == Usul::Shared::Preferences::instance().getBool ( Usul::Registry::Keys::ALLOW_SPIN ) )
    {
      // Flush the mouse events to prevent a slight motion.
      this->flushMouseEventStack();
      this->addMouseEvent ( ea );
    }

    // Otherwise...
    else
    {
      aa.requestRedraw();
    }
  }

  // If it's a regular frame event...
  else if ( osgGA::GUIEventAdapter::FRAME == ea.getEventType() )
  {
    if ( _thrown )
    {
      if ( this->calcMovement() )
        aa.requestRedraw();
      return true;
    }
    return false;
  }

  // Call the base class's function.
  return BaseClass::handle ( ea, aa );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the distance.
//
///////////////////////////////////////////////////////////////////////////////

void Trackball::distance ( double d )
{
  _distance = d;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the distance.
//
///////////////////////////////////////////////////////////////////////////////

double Trackball::distance() const
{
  return _distance;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the center.
//
///////////////////////////////////////////////////////////////////////////////

void Trackball::center ( const osg::Vec3 &c )
{
  _center = c;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the center.
//
///////////////////////////////////////////////////////////////////////////////

osg::Vec3 Trackball::center() const
{
  return _center;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the rotation.
//
///////////////////////////////////////////////////////////////////////////////

void Trackball::rotation ( const osg::Quat &r )
{
  _rotation = r;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the rotation.
//
///////////////////////////////////////////////////////////////////////////////

osg::Quat Trackball::rotation() const
{
  return _rotation;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the model's scale.
//
///////////////////////////////////////////////////////////////////////////////

void Trackball::modelScale ( double ms )
{
  _modelScale = ms;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the model's scale.
//
///////////////////////////////////////////////////////////////////////////////

double Trackball::modelScale() const
{
  return _modelScale;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the trackball's minimum zoom scale.
//
///////////////////////////////////////////////////////////////////////////////

void Trackball::minimumZoomScale ( double mn )
{
  _minimumZoomScale = mn;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the trackball's minimum zoom scale.
//
///////////////////////////////////////////////////////////////////////////////

double Trackball::minimumZoomScale() const
{
  return _minimumZoomScale;
}
