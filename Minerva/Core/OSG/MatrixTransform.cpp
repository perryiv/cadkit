
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2008, Arizona State University
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//  Created by: Adam Kubach
//
///////////////////////////////////////////////////////////////////////////////

#include "Minerva/Core/OSG/MatrixTransform.h"

using namespace Minerva::Core::OSG;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

MatrixTransform::MatrixTransform() : BaseClass(),
  _mutex(),
  _matrix(),
  _dirty ( false )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

MatrixTransform::~MatrixTransform()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the new matrix.
//
///////////////////////////////////////////////////////////////////////////////

void MatrixTransform::matrix ( const osg::Matrixd& m )
{
  Guard guard ( _mutex );
  
  _matrix = m;
  _dirty = true;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Traverse.
//
///////////////////////////////////////////////////////////////////////////////

void MatrixTransform::traverse ( osg::NodeVisitor& nv )
{
  if ( osg::NodeVisitor::CULL_VISITOR == nv.getVisitorType() && this->_isDirty() )
  {
    Guard guard ( _mutex );
    BaseClass::setMatrix ( _matrix );
    _dirty = false;
  }
  
  // Proceed with traversal.
  BaseClass::traverse ( nv );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Are we dirty?
//
///////////////////////////////////////////////////////////////////////////////

bool MatrixTransform::_isDirty() const
{
  Guard guard ( _mutex );
  return _dirty;
}
