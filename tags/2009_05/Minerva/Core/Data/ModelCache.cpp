
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2008, Arizona State University
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//  Author: Adam Kubach
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Cache osg::Node base on key (usually filename or href).
//
///////////////////////////////////////////////////////////////////////////////

#include "Minerva/Core/Data/ModelCache.h"

#include "Usul/Trace/Trace.h"

using namespace Minerva::Core::Data;

///////////////////////////////////////////////////////////////////////////////
//
//  Initialize static member.
//
///////////////////////////////////////////////////////////////////////////////

ModelCache* ModelCache::_instance ( 0x0 );


///////////////////////////////////////////////////////////////////////////////
//
//  Get the instance.
//
///////////////////////////////////////////////////////////////////////////////

ModelCache& ModelCache::instance()
{
  if ( 0x0 == _instance )
    _instance = new ModelCache;
  return *_instance;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

ModelCache::ModelCache() : 
  _mutex(), 
  _cache()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

ModelCache::~ModelCache()
{
  USUL_TRACE_SCOPE;
  this->clear();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Add the model.
//
///////////////////////////////////////////////////////////////////////////////

void ModelCache::addModel ( const std::string& key, osg::Node* node )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  _cache.insert ( std::make_pair ( key, node ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Clear the cache.
//
///////////////////////////////////////////////////////////////////////////////

void ModelCache::clear()
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  _cache.clear();
}

 
///////////////////////////////////////////////////////////////////////////////
//
//  Is the model cached?
//
///////////////////////////////////////////////////////////////////////////////

bool ModelCache::hasModel ( const std::string& key ) const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _cache.end() != _cache.find ( key );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the model.
//
///////////////////////////////////////////////////////////////////////////////

osg::Node* ModelCache::model ( const std::string& key ) const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  Cache::const_iterator iter ( _cache.find ( key ) );
  return ( iter != _cache.end() ? iter->second.get() : 0x0 );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Remove the model.
//
///////////////////////////////////////////////////////////////////////////////

void ModelCache::removeModel ( const std::string& key )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  _cache.erase ( key );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the mutex.
//
///////////////////////////////////////////////////////////////////////////////

ModelCache::Mutex& ModelCache::mutex() const
{
  USUL_TRACE_SCOPE;
  return _mutex;
}
