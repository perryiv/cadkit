
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Convenient base class.
//
///////////////////////////////////////////////////////////////////////////////

#include "Usul/Base/Object.h"

#include "Usul/Adaptors/MemberFunction.h"
#include "Usul/Functions/SafeCall.h"
#include "Usul/Trace/Trace.h"

using namespace Usul::Base;

USUL_IMPLEMENT_TYPE_ID ( Object );


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Object::Object() : BaseClass(),
  _userData (),
  _name     (),
  _mutex    ( new Object::Mutex )
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Copy constructor.
//
///////////////////////////////////////////////////////////////////////////////

Object::Object ( const Object &m ) : BaseClass ( m ),
  _userData   (),
  _name       (),
  _mutex      ( new Object::Mutex )
{
  USUL_TRACE_SCOPE;
  Guard guard ( m.mutex() );

  _userData = m._userData;
  _name = m._name;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Assignment.
//
///////////////////////////////////////////////////////////////////////////////

Object &Object::operator = ( const Object &m )
{
  USUL_TRACE_SCOPE;
  Guard guard1 ( this->mutex() );
  Guard guard2 ( m.mutex() );

  _userData = m._userData;
  _name = m._name;

  return *this;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Object::~Object()
{
  USUL_TRACE_SCOPE;
  Usul::Functions::safeCall ( Usul::Adaptors::memberFunction ( this, &Object::_destroy ), "1729453311" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destroy the object.
//
///////////////////////////////////////////////////////////////////////////////

void Object::_destroy()
{
  USUL_TRACE_SCOPE;

  _userData = 0x0;
  _name.clear();
  delete _mutex; _mutex = 0x0;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the user-data.
//
///////////////////////////////////////////////////////////////////////////////

void Object::userData ( UserData *data )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  _userData = data;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the user-data. Caller has to lock the mutex.
//
///////////////////////////////////////////////////////////////////////////////

Object::UserData *Object::userData()
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  Object::UserData *data ( _userData.get() );
  return data;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the user-data. Caller has to lock the mutex.
//
///////////////////////////////////////////////////////////////////////////////

const Object::UserData *Object::userData() const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  Object::UserData *data ( _userData.get() );
  return data;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the name.
//
///////////////////////////////////////////////////////////////////////////////

void Object::name ( const std::string &n )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  _name = n;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the name.
//
///////////////////////////////////////////////////////////////////////////////

std::string Object::name() const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return std::string ( _name.begin(), _name.end() ); // More thread-safe?
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the mutex.
//
///////////////////////////////////////////////////////////////////////////////

Object::Mutex &Object::mutex() const
{
  USUL_TRACE_SCOPE;
  return *_mutex;
}
