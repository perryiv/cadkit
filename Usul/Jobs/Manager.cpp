
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Job manager class.
//
///////////////////////////////////////////////////////////////////////////////

#include "Usul/Jobs/Manager.h"
#include "Usul/Adaptors/MemberFunction.h"
#include "Usul/Functions/SafeCall.h"
#include "Usul/Trace/Trace.h"

#include <limits>

using namespace Usul::Jobs;


///////////////////////////////////////////////////////////////////////////////
//
//  Static data members.
//
///////////////////////////////////////////////////////////////////////////////

Manager *Manager::_instance ( 0x0 );


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Manager::Manager() :
  _mutex     (),
  _nextJobId ( 0 ),
  _jobs      (),
  _pool      ( new Usul::Threads::Pool )
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Manager::Manager ( unsigned int poolSize ) :
  _mutex     (),
  _nextJobId ( 0 ),
  _jobs      (),
  _pool      ( new Usul::Threads::Pool ( poolSize ) )
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Manager::~Manager()
{
  USUL_TRACE_SCOPE;
  Usul::Functions::safeCall ( Usul::Adaptors::memberFunction ( this, &Manager::_destroy ), "3016860991" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Singleton construction.
//
///////////////////////////////////////////////////////////////////////////////

Manager &Manager::instance()
{
  USUL_TRACE_SCOPE_STATIC;
  if ( 0x0 == _instance )
  {
    _instance = new Manager;
  }
  return *_instance;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Singleton destruction.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::destroy()
{
  USUL_TRACE_SCOPE_STATIC;
  delete _instance;
  _instance = 0x0;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destroy the members.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::_destroy()
{
  // Wait for all jobs to be done.
  this->wait();

  // This will cause the pool to wait for all tasks, 
  // but there should not be any at this point.
  _pool = 0x0;

  // All jobs should be done.
  _jobs.clear();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Add a job to the list.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::add ( Job *job )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );

  if ( 0x0 != job )
  {
    job->id ( this->nextJobId () );
    _pool->addTask ( job->_startedCB, job->_finishedCB, job->_cancelledCB, job->_errorCB, 0x0 );
    _jobs.push_back ( Job::RefPtr ( job ) );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the mutex. Use with caution.
//
///////////////////////////////////////////////////////////////////////////////

Manager::Mutex &Manager::mutex() const
{
  USUL_TRACE_SCOPE;
  return _mutex;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the next job id. This will also increment the internal counter.
//
///////////////////////////////////////////////////////////////////////////////

unsigned long Manager::nextJobId()
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  unsigned long id ( _nextJobId++ );
  return id;
}


///////////////////////////////////////////////////////////////////////////////
//
//  See if the list of jobs is empty.
//
///////////////////////////////////////////////////////////////////////////////

bool Manager::empty() const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _jobs.empty();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Wait for all jobs to complete.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::wait ( unsigned long timeout )
{
  USUL_TRACE_SCOPE;
  _pool->wait ( timeout );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Wait for all tasks to complete.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::wait()
{
  USUL_TRACE_SCOPE;
  this->wait ( std::numeric_limits<unsigned long>::max() );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Resize the thread pool.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::poolResize ( unsigned int numThreads )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  _pool = new ThreadPool ( numThreads );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the thread pool size.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Manager::poolSize() const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _pool->numThreads();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Cancel all threads.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::cancel()
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  _pool->cancel();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Purge all threads that are ready to be deleted.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::purge()
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );

  // Remove all jobs that are ready.
  _jobs.remove_if ( std::mem_fun ( &Job::isDone ) );
}
