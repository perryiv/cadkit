
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2007, Arizona State University
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//  Author: Adam Kubach
//
///////////////////////////////////////////////////////////////////////////////

#include "Helios/Plugins/Animate/Path.h"

#include "Usul/Math/Transpose.h"
#include "Usul/Errors/Assert.h"
#include "Usul/Interfaces/IFrameStamp.h"
#include "Usul/Interfaces/IViewMatrix.h"
#include "Usul/Interfaces/IRenderLoop.h"
#include "Usul/Factory/RegisterCreator.h"
#include "Usul/File/Path.h"
#include "Usul/Strings/Case.h"

#include "Serialize/XML/Deserialize.h"
#include "Serialize/XML/Serialize.h"

#include "osg/FrameStamp"

using namespace Animate;

USUL_IMPLEMENT_IUNKNOWN_MEMBERS ( Path, Path::BaseClass );

///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Path::Path ( const std::string& type ) : 
  BaseClass ( type ),
  _dirty ( false ),
  _acceptNewFrames ( false ),
  _startTime ( -1.0 ),
  _animating( false ),
  _renderLoopState ( false )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Path::~Path ()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the dirty flag.
//
///////////////////////////////////////////////////////////////////////////////

void Path::dirty ( bool b )
{
  Guard guard ( this->mutex () );
  _dirty = b;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the dirty flag.
//
///////////////////////////////////////////////////////////////////////////////

bool Path::dirty () const
{
  Guard guard ( this->mutex () );
  return _dirty;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Start the animation from beginning.
//
///////////////////////////////////////////////////////////////////////////////

void Path::start ( Usul::Interfaces::IUnknown * caller )
{
  Usul::Interfaces::IFrameStamp::QueryPtr fs ( caller );
  if ( fs.valid() )
  {
    Guard guard ( this->mutex () );
    _startTime = fs->frameStamp ()->getReferenceTime ();
  }

  this->animating ( true );

  Usul::Interfaces::IRenderLoop::QueryPtr rl ( caller );
  if ( rl.valid ( ) )
  {
    Guard guard ( this->mutex () );
    _renderLoopState = rl->renderLoop ();
    rl->renderLoop ( true );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Stop the animation.
//
///////////////////////////////////////////////////////////////////////////////

void Path::stop ( Usul::Interfaces::IUnknown * caller )
{
  this->animating ( false );

  Usul::Interfaces::IRenderLoop::QueryPtr rl ( caller );
  if ( rl.valid ( ) )
  {
    Guard guard ( this->mutex () );
    rl->renderLoop ( _renderLoopState );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the animating flag.
//
///////////////////////////////////////////////////////////////////////////////

void Path::animating ( bool b )
{
  Guard guard ( this->mutex () );
  _animating = b;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Are we animating?
//
///////////////////////////////////////////////////////////////////////////////

bool Path::animating () const
{
  Guard guard ( this->mutex () );
  return _animating;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set flag to accept new frames.
//
///////////////////////////////////////////////////////////////////////////////

void Path::acceptNewFrames ( bool b )
{
  Guard guard ( this->mutex () );
  _acceptNewFrames = b;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set flag to accept new frames.
//
///////////////////////////////////////////////////////////////////////////////

bool Path::acceptNewFrames () const
{
  Guard guard ( this->mutex () );
  return _acceptNewFrames;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append a frame.
//
///////////////////////////////////////////////////////////////////////////////

void Path::append ( Frame* frame )
{
  if ( this->acceptNewFrames () )
    this->_append ( frame );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Query for interface.
//
///////////////////////////////////////////////////////////////////////////////

Usul::Interfaces::IUnknown* Path::queryInterface ( unsigned long iid )
{
  switch ( iid )
  {
  case Usul::Interfaces::IUnknown::IID:
  case Usul::Interfaces::IUpdateListener::IID:
    return static_cast < Usul::Interfaces::IUpdateListener * > ( this );
  default:
    return 0x0;
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Update.
//
///////////////////////////////////////////////////////////////////////////////

void Path::updateNotify ( Usul::Interfaces::IUnknown *caller )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return true if this document can do it.
//
///////////////////////////////////////////////////////////////////////////////

bool Path::canExport ( const std::string &file ) const
{
  return this->canSave ( file );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return true if this document can do it.
//
///////////////////////////////////////////////////////////////////////////////

bool Path::canInsert ( const std::string &file ) const
{
  return this->canSave ( file );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return true if this document can do it.
//
///////////////////////////////////////////////////////////////////////////////

bool Path::canOpen ( const std::string &file ) const
{
  return this->canSave ( file );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return true if this document can do it.
//
///////////////////////////////////////////////////////////////////////////////

bool Path::canSave ( const std::string &file ) const
{
  const std::string ext ( Usul::Strings::lowerCase ( Usul::File::extension ( file ) ) );
  return ( ext == this->extension () );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the filters that correspond to what this document can export.
//
///////////////////////////////////////////////////////////////////////////////

Path::Filters Path::filtersExport() const
{
  return this->filtersSave ();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the filters that correspond to what this document can insert.
//
///////////////////////////////////////////////////////////////////////////////

Path::Filters Path::filtersInsert() const
{
  return this->filtersSave ();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the filters that correspond to what this document can open.
//
//////////////////////////////////////////////////////////////////////////////

Path::Filters Path::filtersOpen()   const
{
  return this->filtersSave ();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the filters that correspond to what this document can save.
//
///////////////////////////////////////////////////////////////////////////////

Path::Filters Path::filtersSave()   const
{
  Filters filters;
  filters.push_back ( Filter ( this->name() + " (*." + this->extension () + ")", "*." + this->extension () ) );
  return filters;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Read.
//
///////////////////////////////////////////////////////////////////////////////

void Path::read ( const std::string &filename, Unknown *caller, Unknown *progress )
{
  Serialize::XML::deserialize ( filename, *this );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Write.
//
///////////////////////////////////////////////////////////////////////////////

void Path::write ( const std::string &filename, Unknown *caller, Unknown *progress ) const
{
  Serialize::XML::serialize ( "Path", *this, filename );
}
