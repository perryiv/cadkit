
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2007, Arizona State University
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//  Author: Adam Kubach
//
///////////////////////////////////////////////////////////////////////////////

#include "VRV/Animate/Path.h"

#include "Usul/Math/Transpose.h"
#include "Usul/Errors/Assert.h"
#include "Usul/Interfaces/IFrameStamp.h"
#include "Usul/Interfaces/IViewMatrix.h"
#include "Usul/Factory/RegisterCreator.h"

#include "osg/FrameStamp"

using namespace VRV::Animate;

//USUL_FACTORY_REGISTER_CREATOR_WITH_NAME ( "MatrixPath", Path );

///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Path::Path () : 
  BaseClass (),
  _dirty ( false ),
  _acceptNewFrames ( false ),
  _numberSteps ( 50 ),
  _currentStep ( 0 ),
  _startTime ( -1.0 ),
  _animating( false )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Path::~Path ()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the dirty flag.
//
///////////////////////////////////////////////////////////////////////////////

void Path::dirty ( bool b )
{
  Guard guard ( this->mutex () );
  _dirty = b;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the dirty flag.
//
///////////////////////////////////////////////////////////////////////////////

bool Path::dirty () const
{
  Guard guard ( this->mutex () );
  return _dirty;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Start the animation from beginning.
//
///////////////////////////////////////////////////////////////////////////////

void Path::start ( Usul::Interfaces::IUnknown * caller )
{
  {
    Guard guard ( this->mutex () );
    _currentStep = 0;
  }

  Usul::Interfaces::IFrameStamp::QueryPtr fs ( caller );
  if ( fs.valid() )
  {
    Guard guard ( this->mutex () );
    _startTime = fs->frameStamp ()->getReferenceTime ();
  }

  {
    Guard guard ( this->mutex () );
    _animating = true;
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Are we animating?
//
///////////////////////////////////////////////////////////////////////////////

bool Path::animating () const
{
  Guard guard ( this->mutex () );
  return _animating;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the number of animation steps.
//
///////////////////////////////////////////////////////////////////////////////

void Path::steps ( unsigned int value )
{
  Guard guard ( this->mutex () );
  _numberSteps = value;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the number of animation steps.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Path::steps ( ) const
{
  Guard guard ( this->mutex () );
  return _numberSteps;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set flag to accept new frames.
//
///////////////////////////////////////////////////////////////////////////////

void Path::acceptNewFrames ( bool b )
{
  Guard guard ( this->mutex () );
  _acceptNewFrames = b;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set flag to accept new frames.
//
///////////////////////////////////////////////////////////////////////////////

bool Path::acceptNewFrames () const
{
  Guard guard ( this->mutex () );
  return _acceptNewFrames;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append a frame.
//
///////////////////////////////////////////////////////////////////////////////

void Path::append ( Frame* frame )
{
  if ( this->acceptNewFrames () )
    this->_append ( frame );
}
