
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2007, Arizona State University
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//  Author: Adam Kubach
//
///////////////////////////////////////////////////////////////////////////////

#include "Helios/Plugins/Animate/RecordedPath.h"

#include "Usul/Interfaces/IViewMatrix.h"
#include "Usul/Factory/RegisterCreator.h"

using namespace Animate;

USUL_FACTORY_REGISTER_CREATOR_WITH_NAME ( "RecordedPath", RecordedPath );

///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

RecordedPath::RecordedPath () : 
  BaseClass (),
  _frames (),
  _current ()
{
  this->_addMember ( "Frames", _frames );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

RecordedPath::~RecordedPath ()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append a frame.
//
///////////////////////////////////////////////////////////////////////////////

void RecordedPath::_append ( Frame* frame )
{
  {
    Guard guard ( this->mutex () );
    _frames.push_back ( frame );
  }
  this->dirty ( true );
}

///////////////////////////////////////////////////////////////////////////////
//
//  Start the animation from beginning.
//
///////////////////////////////////////////////////////////////////////////////

void RecordedPath::start ( Usul::Interfaces::IUnknown * caller )
{
  if ( false == _frames.empty () )
  {
    _current = _frames.begin ();
    BaseClass::start ( caller );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Animate or record.
//
///////////////////////////////////////////////////////////////////////////////

void RecordedPath::updateNotify ( Usul::Interfaces::IUnknown * caller )
{
  this->_record ( caller );
  this->_animate ( caller );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Animate one step.
//
///////////////////////////////////////////////////////////////////////////////

void RecordedPath::_animate ( Usul::Interfaces::IUnknown * caller )
{
  if ( false == this->animating () )
    return;

  Usul::Interfaces::IViewMatrix::QueryPtr vm ( caller );

  if ( vm.valid () )
  {
    Guard guard ( this->mutex () );
    if ( _current != _frames.end () )
    {
      vm->setViewMatrix ( (*_current)->matrix () );
      ++_current;
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Animate one step.
//
///////////////////////////////////////////////////////////////////////////////

void RecordedPath::_record ( Usul::Interfaces::IUnknown * caller )
{
  if ( false == this->acceptNewFrames () )
    return;

  Usul::Interfaces::IViewMatrix::QueryPtr vm ( caller );

  if ( vm.valid () )
  {
    Guard guard ( this->mutex () );
    _frames.push_back ( new Frame ( vm->getViewMatrix() ) );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Clear.
//
///////////////////////////////////////////////////////////////////////////////

void RecordedPath::clear ()
{
  {
    Guard guard ( this->mutex () );
    _frames.clear();
  }
  this->dirty ( true );
}

