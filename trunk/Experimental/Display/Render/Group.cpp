
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2007, Perry L Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//  Author: Perry L Miller IV
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Group of renderers.
//
///////////////////////////////////////////////////////////////////////////////

#include "Display/Render/Group.h"

#include "Usul/Adaptors/MemberFunction.h"
#include "Usul/Functions/SafeCall.h"
#include "Usul/Threads/Safe.h"
#include "Usul/Trace/Trace.h"

using namespace Display::Render;

USUL_IMPLEMENT_TYPE_ID ( Group );


/////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
/////////////////////////////////////////////////////////////////////////////

Group::Group() : BaseClass(),
  _renderers()
{
  USUL_TRACE_SCOPE;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
/////////////////////////////////////////////////////////////////////////////

Group::~Group()
{
  USUL_TRACE_SCOPE;
  Usul::Functions::safeCall ( Usul::Adaptors::memberFunction ( this, &Group::_destroy ), "3781756854" );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Destroy this instance.
//
/////////////////////////////////////////////////////////////////////////////

void Group::_destroy()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Pre-render notifcation.
//
///////////////////////////////////////////////////////////////////////////////

void Group::_preRender()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Post-render notifcation.
//
///////////////////////////////////////////////////////////////////////////////

void Group::_postRender()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Render the scene.
//
///////////////////////////////////////////////////////////////////////////////

void Group::_render()
{
  USUL_TRACE_SCOPE;

  // Loop through all the renderers.
  Renderers renderers ( Usul::Threads::Safe::get ( this->mutex(), _renderers ) );
  for ( Renderers::iterator i = renderers.begin(); i != renderers.end(); ++i )
  {
    Renderer::RefPtr r ( *i );
    if ( true == r.valid() )
    {
      // Render the scene.
      r->render();
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the scene.
//
///////////////////////////////////////////////////////////////////////////////

void Group::scene ( NodePtr node )
{
  USUL_TRACE_SCOPE;
  BaseClass::scene ( node );

  // Loop through all the renderers.
  Renderers renderers ( Usul::Threads::Safe::get ( this->mutex(), _renderers ) );
  for ( Renderers::iterator i = renderers.begin(); i != renderers.end(); ++i )
  {
    Renderer::RefPtr r ( *i );
    if ( true == r.valid() )
    {
      // Set the scene.
      r->scene ( node );
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Call this when you want the viewport to resize.
//
///////////////////////////////////////////////////////////////////////////////

void Group::resize ( unsigned int w, unsigned int h )
{
  USUL_TRACE_SCOPE;
  BaseClass::resize ( w, h );

  Renderers r ( Usul::Threads::Safe::get ( this->mutex(), _renderers ) );
  for ( Renderers::iterator i = r.begin(); i != r.end(); ++i )
  {
    Renderers::value_type renderer ( *i );
    if ( true == renderer.valid() )
    {
      renderer->resize ( w, h );
    }
  }
}
