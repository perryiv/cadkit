
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Base class for all objects.
//
///////////////////////////////////////////////////////////////////////////////

#include "AppFrameWork/Core/Object.h"
#include "AppFrameWork/Core/Define.h"

#include "Usul/Errors/Assert.h"
#include "Usul/MPL/SameType.h"

#include <iostream>
#include <stdexcept>

using namespace AFW::Core;

USUL_IMPLEMENT_TYPE_ID ( Object );


///////////////////////////////////////////////////////////////////////////////
//
//  Local typedefs.
//
///////////////////////////////////////////////////////////////////////////////

typedef Usul::Threads::Guard < Object::ObjectListVar::MutexType > ObjectListGuard;


///////////////////////////////////////////////////////////////////////////////
//
//  Static data member(s).
//
///////////////////////////////////////////////////////////////////////////////

Object::ObjectListVar Object::_allObjects;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Object::Object() : BaseClass(),
  _mutex       (),
  _whichObject ( _allObjects.value().end() ),
  _userData    ()
{
  typedef std::list < Object::ValidRefPtr > ListOfObjects;
  typedef std::iterator_traits < Object::ObjectList::iterator > Traits1;
  typedef std::iterator_traits < ListOfObjects::iterator > Traits2;
  typedef Traits1::iterator_category Category1;
  typedef Traits2::iterator_category Category2;
  USUL_ASSERT_SAME_TYPE ( Category1, Category2 );

  // Relies on the fact that list iterators are not invalidated.
  ObjectListGuard guard ( _allObjects.mutex() );
  _whichObject = _allObjects.value().insert ( _allObjects.value().end(), this );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Object::~Object()
{
  // Safely...
  try
  {
    ObjectListGuard guard ( _allObjects.mutex() );
    USUL_ASSERT ( false == _allObjects.value().empty() );

    // Relies on the fact that list iterators are not invalidated.
    _allObjects.value().erase ( _whichObject );
  }

  // Catch exceptions.
  AFW_CATCH_BLOCK ( "1072220024", "2486162374" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the user-data.
//
///////////////////////////////////////////////////////////////////////////////

const Object::UserData *Object::userData() const
{
  Guard guard ( this->mutex() );
  return _userData.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the user-data.
//
///////////////////////////////////////////////////////////////////////////////

Object::UserData *Object::userData()
{
  Guard guard ( this->mutex() );
  return _userData.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the user-data.
//
///////////////////////////////////////////////////////////////////////////////

void Object::userData ( UserData *data )
{
  Guard guard ( this->mutex() );
  _userData = data;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterator to the list of all objects.
//
///////////////////////////////////////////////////////////////////////////////

Object::ObjectListItr Object::allObjectsBegin()
{
  ObjectListGuard guard ( _allObjects.mutex() );
  return _allObjects.value().begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterator to the list of all objects.
//
///////////////////////////////////////////////////////////////////////////////

Object::ObjectListItr Object::allObjectsEnd()
{
  ObjectListGuard guard ( _allObjects.mutex() );
  return _allObjects.value().end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Access to the mutex.
//
///////////////////////////////////////////////////////////////////////////////

Object::Mutex &Object::mutex() const
{
  return _mutex;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Default implementation does nothing.
//
///////////////////////////////////////////////////////////////////////////////

void Object::detach()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Unreference the instance.
//
///////////////////////////////////////////////////////////////////////////////

void Object::unref ( bool allowDeletion )
{
  // If we are about to die, then detach. It is too late to do this in the 
  // destructor because the virtual table is already gone.
  if ( 1 == this->refCount() )
    this->detach();

  // Call base class's function.
  BaseClass::unref ( allowDeletion );
}
