
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2005, Adam Kubach & Perry Miller
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Image class.
//
///////////////////////////////////////////////////////////////////////////////

#include "Images/Core/Image.h"
#include "Images/Core/ImageImpl.h"
#include "Images/Core/Factory.h"

#include "Usul/Strings/Case.h"
#include "Usul/File/Path.h"
#include "Usul/Components/Manager.h"
#include "Usul/Interfaces/IRead.h"
#include "Usul/Interfaces/IReadTIFF.h"
#include "Usul/Interfaces/IReadImage.h"
#include "Usul/Interfaces/IGetImageProperties.h"

using namespace Images;


///////////////////////////////////////////////////////////////////////////////
//
//  Typedefs.
//
///////////////////////////////////////////////////////////////////////////////

typedef Usul::Components::Manager PluginManager;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Image::Image ( unsigned int bytes, bool floating ) : BaseClass(),
  _image ( Images::Factory::create ( bytes, floating ) )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Copy constructor.
//
///////////////////////////////////////////////////////////////////////////////

Image::Image ( const Image &image ) : BaseClass ( image ),
  _image ( image._image->clone() )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Image::~Image()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the width.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Image::width() const
{
  return _image->width();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the height.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Image::height() const
{
  return _image->height();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the number of channels.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Image::channels() const
{
  return _image->channels();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Helper class for reading an image.
//
///////////////////////////////////////////////////////////////////////////////

namespace Detail
{
  template < class InterfaceType_ > struct Reader
  {
    static ::Images::BaseImage *read ( const std::string &name )
    {
      typedef Usul::Interfaces::IRead IRead;
      typedef InterfaceType_ InterfaceType;
      typedef Usul::Interfaces::IGetImageProperties IGetImageProperties;

      // Default TIFF reader truncates 16-bit pixels, so we use our own reader.
      InterfaceType::QueryPtr tiff ( PluginManager::instance().getInterface ( InterfaceType::IID ) );

      // Get other interfaces.
      IRead::QueryPtr reader ( tiff );
      IGetImageProperties::QueryPtr props ( tiff );

      // See if we have the interfaces we need...
      if ( false == reader.valid() || false == props.valid() )
        return 0x0;

      // Read the image.
      reader->read ( name );

      // See what kind it is.
      unsigned int bytes ( props->getNumBytesPerValue() );
      bool floating ( props->isValueFloatingPoint() );

      // Make image of proper kind.
      return Images::Factory::create ( bytes, floating, reader );
    }
  };
}


///////////////////////////////////////////////////////////////////////////////
//
//  Read the image.
//
///////////////////////////////////////////////////////////////////////////////

void Image::read ( const std::string &name )
{
  typedef Usul::Interfaces::IRead IRead;
  typedef Usul::Interfaces::IReadTIFF IReadTIFF;
  typedef Usul::Interfaces::IReadImage IReadImage;
  typedef Usul::Interfaces::IGetImageProperties IGetImageProperties;

  // Get extension.
  const std::string ext ( Usul::Strings::lowerCase ( Usul::File::extension ( name ) ) );

  // Declare here.
  Images::BaseImage::RefPtr image ( 0x0 );

  // Do we have a tiff image?
  if ( ext == "tif" || ext == "tiff" )
    image = Detail::Reader<IReadTIFF>::read ( name );

  // Assign our image. Use default reader is needed.
  _image = ( image.valid() ) ? image : Detail::Reader<IReadImage>::read ( name );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Convert to grayscale.
//
///////////////////////////////////////////////////////////////////////////////

void Image::toGrayScale()
{
  _image->toGrayScale();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Calculate the histogram.
//
///////////////////////////////////////////////////////////////////////////////

void Image::histogram ( Histogram &h ) const
{
  _image->histogram ( h );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get extreme values in all the channels.
//
///////////////////////////////////////////////////////////////////////////////

void Image::extremes ( ValueCount &low, ValueCount &high ) const
{
  _image->extremes ( low, high );
}
