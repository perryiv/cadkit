
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Base class for all windows.
//
///////////////////////////////////////////////////////////////////////////////

#include "AppFrameWork/Core/Group.h"
#include "AppFrameWork/Core/BaseVisitor.h"
#include "AppFrameWork/Core/Define.h"
#include "AppFrameWork/Core/Program.h"
#include "AppFrameWork/Core/Application.h"

#include "Usul/Bits/Bits.h"
#include "Usul/Errors/Assert.h"
#include "Usul/MPL/SameType.h"

#include <iostream>
#include <stdexcept>

using namespace AFW::Core;

AFW_IMPLEMENT_OBJECT ( Window );


///////////////////////////////////////////////////////////////////////////////
//
//  Local typedefs.
//
///////////////////////////////////////////////////////////////////////////////

typedef Usul::Threads::Guard < Window::WindowListVar::MutexType > WindowListGuard;


///////////////////////////////////////////////////////////////////////////////
//
//  Static data member(s).
//
///////////////////////////////////////////////////////////////////////////////

Window::WindowListVar Window::_allWindows;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Window::Window() : BaseClass(),
  _whichWindow ( _allWindows.value().end() ),
  _flags       ( State::DIRTY ),
  _parent      ( 0x0 ),
  _icon        (),
  _text        (),
  _title       (),
  _regName     (),
  _commands    (),
  _updates     (),
  _dockState   ( AFW::Core::DockSite::NONE, 0 ),
  _devices     ()
{
  typedef std::list < Window::ValidRefPtr > ListOfWindows;
  typedef std::iterator_traits < Window::WindowList::iterator > Traits1;
  typedef std::iterator_traits < ListOfWindows::iterator > Traits2;
  typedef Traits1::iterator_category Category1;
  typedef Traits2::iterator_category Category2;
  USUL_ASSERT_SAME_TYPE ( Category1, Category2 );

  // Relies on the fact that list iterators are not invalidated.
  WindowListGuard guard ( _allWindows.mutex() );
  _whichWindow = _allWindows.value().insert ( _allWindows.value().end(), this );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Window::~Window()
{
  // Safely...
  try
  {
    WindowListGuard guard ( _allWindows.mutex() );
    USUL_ASSERT ( false == _allWindows.value().empty() );

    // Relies on the fact that list iterators are not invalidated.
    _allWindows.value().erase ( _whichWindow );

    // The parent is now dirty.
    if ( _parent )
      _parent->dirty ( true );
  }

  // Catch exceptions.
  AFW_CATCH_BLOCK ( "3539223479", "3180678094" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the dirty flag.
//
///////////////////////////////////////////////////////////////////////////////

void Window::dirty ( bool state )
{
  Guard guard ( this->mutex() );
  const unsigned int bit ( State::DIRTY );
  _flags = Usul::Bits::set ( _flags, bit, state );

  // If dirty, set parent as dirty too.
  if ( state && _parent )
    _parent->dirty ( true );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the dirty flag.
//
///////////////////////////////////////////////////////////////////////////////

bool Window::dirty() const
{
  Guard guard ( this->mutex() );
  const unsigned int bit ( State::DIRTY );
  return Usul::Bits::has ( _flags, bit );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the parent.
//
///////////////////////////////////////////////////////////////////////////////

const Group *Window::parent() const
{
  Guard guard ( this->mutex() );
  return _parent;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the parent.
//
///////////////////////////////////////////////////////////////////////////////

Group *Window::parent()
{
  Guard guard ( this->mutex() );
  return _parent;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the text.
//
///////////////////////////////////////////////////////////////////////////////

std::string Window::textGet() const
{
  Guard guard ( this->mutex() );
  return _text;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the text.
//
///////////////////////////////////////////////////////////////////////////////

void Window::textGet ( std::string &s ) const
{
  Guard guard ( this->mutex() );
  s = _text;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the text.
//
///////////////////////////////////////////////////////////////////////////////

void Window::textSet ( const std::string &t )
{
  Guard guard ( this->mutex() );
  _text = t;
  this->dirty ( true );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the text.
//
///////////////////////////////////////////////////////////////////////////////

void Window::textSet ( const char *t, unsigned int length )
{
  Guard guard ( this->mutex() );
  if ( t )
  {
    _text.assign ( t, t + length );
    this->dirty ( true );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append the text.
//
///////////////////////////////////////////////////////////////////////////////

void Window::textAppend ( const std::string &t )
{
  Guard guard ( this->mutex() );
  _text += t;
  this->dirty ( true );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append the text.
//
///////////////////////////////////////////////////////////////////////////////

void Window::textAppend ( const char *t, unsigned int length )
{
  Guard guard ( this->mutex() );
  if ( t )
  {
    _text.insert ( _text.end(), t, t + length );
    this->dirty ( true );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the title.
//
///////////////////////////////////////////////////////////////////////////////

std::string Window::title() const
{
  Guard guard ( this->mutex() );
  return _title;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the title.
//
///////////////////////////////////////////////////////////////////////////////

void Window::title ( const std::string &t )
{
  Guard guard ( this->mutex() );
  _title = t;
  this->dirty ( true );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append an action.
//
///////////////////////////////////////////////////////////////////////////////

void Window::append ( AFW::Actions::CommandAction *c )
{
  Guard guard ( this->mutex() );
  if ( c )
    _commands.push_back ( c );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append an action.
//
///////////////////////////////////////////////////////////////////////////////

void Window::append ( AFW::Conditions::Condition *c, AFW::Actions::UpdateAction *u )
{
  Guard guard ( this->mutex() );
  if ( c && u )
    _updates.push_back ( UpdatePair ( c, u ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append a device.
//
///////////////////////////////////////////////////////////////////////////////

void Window::append ( BaseDevice *d )
{
  Guard guard ( this->mutex() );
  if ( d )
    _devices.push_back ( d );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the parent.
//
///////////////////////////////////////////////////////////////////////////////

void Window::_setParent ( Group *parent )
{
  Guard guard ( this->mutex() );
  _parent = parent;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the icon.
//
///////////////////////////////////////////////////////////////////////////////

AFW::Core::Icon Window::icon() const
{
  Guard guard ( this->mutex() );
  return Icon ( _icon );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the icon.
//
///////////////////////////////////////////////////////////////////////////////

void Window::icon ( const AFW::Core::Icon &icon )
{
  Guard guard ( this->mutex() );
  _icon = icon;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::CommandActionsItr Window::commandsBegin()
{
  Guard guard ( this->mutex() );
  return _commands.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::CommandActionsConstItr Window::commandsBegin() const
{
  Guard guard ( this->mutex() );
  return _commands.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::CommandActionsItr Window::commandsEnd()
{
  Guard guard ( this->mutex() );
  return _commands.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::CommandActionsConstItr Window::commandsEnd() const
{
  Guard guard ( this->mutex() );
  return _commands.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::UpdatePairsItr Window::updatesBegin()
{
  Guard guard ( this->mutex() );
  return _updates.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::UpdatePairsConstItr Window::updatesBegin() const
{
  Guard guard ( this->mutex() );
  return _updates.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::UpdatePairsItr Window::updatesEnd()
{
  Guard guard ( this->mutex() );
  return _updates.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::UpdatePairsConstItr Window::updatesEnd() const
{
  Guard guard ( this->mutex() );
  return _updates.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::DevicesItr Window::devicesBegin()
{
  Guard guard ( this->mutex() );
  return _devices.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::DevicesConstItr Window::devicesBegin() const
{
  Guard guard ( this->mutex() );
  return _devices.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::DevicesItr Window::devicesEnd()
{
  Guard guard ( this->mutex() );
  return _devices.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the devices.
//
///////////////////////////////////////////////////////////////////////////////

Window::DevicesConstItr Window::devicesEnd() const
{
  Guard guard ( this->mutex() );
  return _devices.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Call the actions.
//
///////////////////////////////////////////////////////////////////////////////

void Window::callCommandActions ( bool immediate )
{
  Guard guard ( this->mutex() );
  for ( CommandActionsItr i = _commands.begin(); i != _commands.end(); ++i )
  {
    CommandAction::RefPtr command ( *i );
    if ( command.valid() )
    {
      if ( immediate )
      {
        command->execute ( this );
      }
      else
      {
        if ( Program::valid() && Program::instance().app() )
        {
          AFW_GUARD_PROGRAM;
          Program::instance().app()->eventAppend ( command.get(), this );
        }
      }
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Call the actions.
//
///////////////////////////////////////////////////////////////////////////////

void Window::callUpdateActions ( bool immediate )
{
  Guard guard ( this->mutex() );
  for ( UpdatePairsItr i = _updates.begin(); i != _updates.end(); ++i )
  {
    UpdatePair update ( *i );
    AFW::Conditions::Condition::RefPtr condition ( update.first );
    AFW::Actions::UpdateAction::RefPtr action ( update.second );
    if ( condition.valid() && action.valid() )
    {
      if ( condition->evaluate ( this ) )
      {
        if ( immediate )
        {
          action->execute ( this );
        }
        else
        {
          if ( Program::valid() && Program::instance().app() )
          {
            AFW_GUARD_PROGRAM;
            Program::instance().app()->eventAppend ( action.get(), this );
          }
        }
      }
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the docked state.
//
///////////////////////////////////////////////////////////////////////////////

void Window::dockState ( DockState state )
{
  Guard guard ( this->mutex() );

  // Handle unchanged case.
  if ( this->dockState() == state )
    return;

  // Set the flag.
  _dockState = state;

  // We are dirty.
  this->dirty ( true );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the docked state.
//
///////////////////////////////////////////////////////////////////////////////

Window::DockState Window::dockState() const
{
  Guard guard ( this->mutex() );
  return _dockState;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterator to the list of all windows.
//
///////////////////////////////////////////////////////////////////////////////

Window::WindowListItr Window::allWindowsBegin()
{
  WindowListGuard guard ( _allWindows.mutex() );
  return _allWindows.value().begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterator to the list of all windows.
//
///////////////////////////////////////////////////////////////////////////////

Window::WindowListItr Window::allWindowsEnd()
{
  WindowListGuard guard ( _allWindows.mutex() );
  return _allWindows.value().end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Accept the visitor.
//
///////////////////////////////////////////////////////////////////////////////

void Window::accept ( AFW::Core::BaseVisitor *v )
{
  Guard guard ( this->mutex() );
  if ( v )
    v->visit ( this );
}


///////////////////////////////////////////////////////////////////////////////
//
//  This function is plumbing for the visitor pattern.
//
///////////////////////////////////////////////////////////////////////////////

void Window::_traverse ( AFW::Core::BaseVisitor * )
{
  Guard guard ( this->mutex() );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Default implementation does nothing.
//
///////////////////////////////////////////////////////////////////////////////

void Window::scrollToEnd()
{
  Guard guard ( this->mutex() );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the persistent name.
//
///////////////////////////////////////////////////////////////////////////////

void Window::persistentName ( const std::string &n )
{
  Guard guard ( this->mutex() );
  _regName = n;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the persistent name.
//
///////////////////////////////////////////////////////////////////////////////

std::string Window::persistentName() const
{
  Guard guard ( this->mutex() );
  return std::string ( _regName );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Enable the window.
//
///////////////////////////////////////////////////////////////////////////////

void Window::enable ( bool state )
{
  Guard guard ( this->mutex() );
  const unsigned int bit ( State::ENABLED );
  _flags = Usul::Bits::set ( _flags, bit, state );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the enabled flag.
//
///////////////////////////////////////////////////////////////////////////////

bool Window::enabled() const
{
  Guard guard ( this->mutex() );
  const unsigned int bit ( State::ENABLED );
  return Usul::Bits::has ( _flags, bit );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the visible state.
//
///////////////////////////////////////////////////////////////////////////////

void Window::visible ( bool state )
{
  Guard guard ( this->mutex() );
  const unsigned int bit ( State::VISIBLE );
  _flags = Usul::Bits::set ( _flags, bit, state );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the visible flag.
//
///////////////////////////////////////////////////////////////////////////////

bool Window::visible() const
{
  Guard guard ( this->mutex() );
  const unsigned int bit ( State::VISIBLE );
  return Usul::Bits::has ( _flags, bit );
}
