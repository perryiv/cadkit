
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  The state attributes.
//
///////////////////////////////////////////////////////////////////////////////

#include "GSG/Core/Precompiled.h"
#include "GSG/Core/AttributeSet.h"
#include "GSG/Core/Material.h"

using namespace GSG;

GSG_IMPLEMENT_REFERENCED ( AttributeSet );


/////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
/////////////////////////////////////////////////////////////////////////////

AttributeSet::AttributeSet() : Referenced(),
  _attributes()
{
}


/////////////////////////////////////////////////////////////////////////////
//
//  Copy constructor.
//
/////////////////////////////////////////////////////////////////////////////

AttributeSet::AttributeSet ( const AttributeSet &a ) : Referenced ( a ),
  _attributes ( a._attributes )
{
}


/////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
/////////////////////////////////////////////////////////////////////////////

AttributeSet::~AttributeSet()
{
}


/////////////////////////////////////////////////////////////////////////////
//
//  Remove any attribute of the given type.
//
/////////////////////////////////////////////////////////////////////////////

void AttributeSet::remove ( const type_info &t )
{
  Lock lock ( this );
  iterator i = this->find ( t );
  if ( _attributes.end() != i )
    _attributes.erase ( i );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Set the attribute. Replaces any existing attributes of the same type.
//
/////////////////////////////////////////////////////////////////////////////

void AttributeSet::set ( Attribute *attr )
{
  Lock lock ( this );

  // Handle bad input.
  if ( 0x0 == attr )
    return;

  // Find the first attribute that matches the given attributes's type.
  // Note: there should not be more than one of the same type.
  for ( iterator i = _attributes.begin(); i != _attributes.end(); ++i )
  {
    Attribute::ValidPtr current ( *i );
    if ( current->typeId() == attr->typeId() )
    {
      // Cast to Referenced in order to walk up the virtual chain.
      current->setFrom ( static_cast < Referenced &> ( *attr ) );
      return;
    }
  }

  // If we get to here then either the container is empty or 
  // we didn't find an attribute of the same type.
  _attributes.insert ( _attributes.end(), Attribute::ValidPtr ( attr ) );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Set from the given object.
//
/////////////////////////////////////////////////////////////////////////////

void AttributeSet::setFrom ( const AttributeSet &a )
{
  Lock lock ( this );

  // Set the members.
  _attributes = a._attributes;

  // Call the base class's function.
  BaseClass::setFrom ( a );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Find the attribute.
//
/////////////////////////////////////////////////////////////////////////////

AttributeSet::iterator AttributeSet::find ( const type_info &t )
{
  return std::find_if ( _attributes.begin(), _attributes.end(), Detail::IsOfType ( t ) );
}


/////////////////////////////////////////////////////////////////////////////
//
//  Find the attribute.
//
/////////////////////////////////////////////////////////////////////////////

AttributeSet::const_iterator AttributeSet::find ( const type_info &t ) const
{
  return std::find_if ( _attributes.begin(), _attributes.end(), Detail::IsOfType ( t ) );
}
