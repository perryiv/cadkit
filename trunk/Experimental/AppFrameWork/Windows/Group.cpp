
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Base class for all groups.
//
///////////////////////////////////////////////////////////////////////////////

#include "AppFrameWork/Windows/Group.h"
#include "AppFrameWork/Core/BaseVisitor.h"
#include "AppFrameWork/Core/Define.h"

#include "Usul/Algorithms/CopyIf.h"
#include "Usul/Bits/Bits.h"
#include "Usul/Errors/Assert.h"

#include <stdexcept>
#include <iostream>
#include <algorithm>

using namespace AFW::Windows;

AFW_IMPLEMENT_OBJECT ( Group );


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Group::Group() : BaseClass(),
  _windows()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Group::~Group()
{
  // Safely...
  try
  {
    this->removeAll();
  }

  // Catch exceptions.
  AFW_CATCH_BLOCK ( 1996818293ul );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append the window.
//
///////////////////////////////////////////////////////////////////////////////

bool Group::append ( Window *w )
{
  Guard guard ( this->mutex() );
  return this->insert ( _windows.end(), w );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Insert the window.
//
///////////////////////////////////////////////////////////////////////////////

bool Group::insert ( Itr where, Window *w )
{
  Guard guard ( this->mutex() );

  // If the window is us.
  if ( this == w )
    return false;

  // Return if the window is not valid, or if it already has a parent.
  if ( 0x0 == w || 0x0 != w->parent() )
    return false;

  // If the window is already a child.
  if ( _windows.end() != this->find ( w ) )
    return false;

  // Try to create the window.
  if ( false == w->create ( this ) )
    return false;

  // Insert it into our list.
  _windows.insert ( where, w );

  // We are now the parent.
  w->_setParent ( this );

  // Set dirty flags.
  w->dirty ( true );
  this->dirty ( true );

  // It worked.
  return true;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Remove the window.
//
///////////////////////////////////////////////////////////////////////////////

void Group::remove ( Window *w )
{
  Guard guard ( this->mutex() );

  // The window does not have a parent now.
  w->_setParent ( 0x0 );

  // Tell the window to detach from it's gui object.
  w->detach();

  // Remove the window.
  _windows.erase ( this->find ( w ) );

  // Set dirty flags.
  w->dirty ( true );
  this->dirty ( true );

  // Should be true.
  USUL_ASSERT ( _windows.end() == this->find ( w ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Remove the window.
//
///////////////////////////////////////////////////////////////////////////////

void Group::remove ( unsigned int i )
{
  if ( i < _windows.size() )
  {
    Window::RefPtr window ( _windows.at ( i ) );
    this->remove ( window.get() );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Remove all windows.
//
///////////////////////////////////////////////////////////////////////////////

void Group::removeAll()
{
  while ( false == _windows.empty() )
  {
    const unsigned int i ( _windows.size() - 1 );
    Window::RefPtr window ( _windows.at ( i ) );
    this->remove ( window.get() );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Look for the child window.
//
///////////////////////////////////////////////////////////////////////////////

Group::ConstItr Group::find ( Window *w ) const
{
  Guard guard ( this->mutex() );
  return ( ( 0x0 == w ) ? _windows.end() : std::find ( _windows.begin(), _windows.end(), Windows::value_type ( w ) ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Look for the child window.
//
///////////////////////////////////////////////////////////////////////////////

Group::Itr Group::find ( Window *w )
{
  Guard guard ( this->mutex() );
  return ( ( 0x0 == w ) ? _windows.end() : std::find ( _windows.begin(), _windows.end(), Windows::value_type ( w ) ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the contained windows.
//
///////////////////////////////////////////////////////////////////////////////

Group::Itr Group::begin()
{
  Guard guard ( this->mutex() );
  return _windows.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the contained windows.
//
///////////////////////////////////////////////////////////////////////////////

Group::ConstItr Group::begin() const
{
  Guard guard ( this->mutex() );
  return _windows.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the contained windows.
//
///////////////////////////////////////////////////////////////////////////////

Group::Itr Group::end()
{
  Guard guard ( this->mutex() );
  return _windows.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the contained windows.
//
///////////////////////////////////////////////////////////////////////////////

Group::ConstItr Group::end() const
{
  Guard guard ( this->mutex() );
  return _windows.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the number of children.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Group::numChildren() const
{
  Guard guard ( this->mutex() );
  return _windows.size();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Accept the visitor.
//
///////////////////////////////////////////////////////////////////////////////

void Group::accept ( AFW::Core::BaseVisitor *v )
{
  Guard guard ( this->mutex() );
  if ( v )
    v->visit ( this );
}


///////////////////////////////////////////////////////////////////////////////
//
//  This function is plumbing for the visitor pattern.
//
///////////////////////////////////////////////////////////////////////////////

void Group::_traverse ( AFW::Core::BaseVisitor *visitor )
{
  Guard guard ( this->mutex() );

  if ( 0x0 == visitor )
    return;

  for ( Group::Itr i = this->begin(); i != this->end(); ++i )
  {
    AFW::Windows::Window::RefPtr window ( i->get() );
    if ( true == window.valid() )
    {
      window->accept ( visitor );
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Write configuration to disk.
//
///////////////////////////////////////////////////////////////////////////////

void Group::configWrite() const
{
  Guard guard ( this->mutex() );
  std::for_each ( this->begin(), this->end(), std::mem_fun ( &AFW::Windows::Window::configWrite ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the visible state of the given window. Typically, the window will be 
//  a child of this group. However, this functions is here so that inheriting 
//  classes can customize, so it isn't important if the given window is a 
//  child or not.
//
///////////////////////////////////////////////////////////////////////////////

void Group::visible ( AFW::Windows::Window *w, bool state )
{
  Guard guard ( this->mutex() );
  if ( w )
  {
    const unsigned int bit ( AFW::Core::State::VISIBLE );
    w->flags ( Usul::Bits::set ( w->flags(), bit, state ) );
  }
}
