
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2005, Adam Kubach & Perry Miller
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Image class.
//
///////////////////////////////////////////////////////////////////////////////

#include "Images/Core/Image.h"
#include "Images/Core/ImageImpl.h"
#include "Images/Core/Factory.h"

#include "Usul/Strings/Case.h"
#include "Usul/File/Path.h"
#include "Usul/Components/Manager.h"
#include "Usul/Interfaces/IRead.h"
#include "Usul/Interfaces/IReadTIFF.h"
#include "Usul/Interfaces/IGetImageProperties.h"

using namespace Images;


///////////////////////////////////////////////////////////////////////////////
//
//  Typedefs.
//
///////////////////////////////////////////////////////////////////////////////

typedef Usul::Components::Manager PluginManager;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Image::Image ( unsigned int bytes, bool floating ) : BaseClass(),
  _image ( Images::Factory::create ( bytes, floating ) )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Copy constructor.
//
///////////////////////////////////////////////////////////////////////////////

Image::Image ( const Image &image ) : BaseClass ( image ),
  _image ( image._image->clone() )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Image::~Image()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the width.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Image::width() const
{
  return _image->width();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the height.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Image::height() const
{
  return _image->height();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the number of channels.
//
///////////////////////////////////////////////////////////////////////////////

unsigned int Image::channels() const
{
  return _image->channels();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Read the image.
//
///////////////////////////////////////////////////////////////////////////////

void Image::read ( const std::string &name )
{
  // Get extension.
  const std::string ext ( Usul::Strings::lowerCase ( Usul::File::extension ( name ) ) );

  // Do we have a tiff image?
  if ( ext == "tif" || ext == "tiff" )
    if ( this->_readTiff ( name ) )
      return;

  // Use default reader.
  _image->read ( name );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Read the TIFF image.
//
///////////////////////////////////////////////////////////////////////////////

bool Image::_readTiff ( const std::string &name )
{
  typedef Usul::Interfaces::IRead IRead;
  typedef Usul::Interfaces::IReadTIFF IReadTIFF;
  typedef Usul::Interfaces::IGetImageProperties IGetImageProperties;

  // Default TIFF reader truncates 16-bit pixels, so we use our own reader.
  IReadTIFF::QueryPtr tiff ( PluginManager::instance().getInterface ( IReadTIFF::IID ) );

  // Get other interfaces.
  IRead::QueryPtr reader ( tiff );
  IGetImageProperties::QueryPtr props ( tiff );

  // See if we have the interfaces we need...
  if ( false == reader.valid() || false == props.valid() )
    return false;

  // Read the image.
  reader->read ( name );

  // See what kind it is.
  unsigned int bytes ( props->getNumBytesPerValue() );
  bool floating ( props->isValueFloatingPoint() );

  // Make image of proper kind.
  Images::BaseImage::ValidRefPtr image ( Images::Factory::create ( bytes, floating, reader ) );

  // Set our image.
  _image = image;

  // It worked.
  return true;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Convert to grayscale.
//
///////////////////////////////////////////////////////////////////////////////

void Image::toGrayScale()
{
  _image->toGrayScale();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Calculate the histogram.
//
///////////////////////////////////////////////////////////////////////////////

void Image::histogram ( Histogram &h ) const
{
  _image->histogram ( h );
}
