
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Job class.
//
///////////////////////////////////////////////////////////////////////////////

#include "Usul/Jobs/Job.h"
#include "Usul/Jobs/Manager.h"
#include "Usul/Adaptors/MemberFunction.h"
#include "Usul/Functions/SafeCall.h"
#include "Usul/Scope/Caller.h"
#include "Usul/Trace/Trace.h"

using namespace Usul::Jobs;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
///////////////////////////////////////////////////////////////////////////////

Job::Job() : BaseClass(),
  _id          ( Usul::Jobs::Manager::instance().nextJobId() ),
  _cancelledCB ( 0x0 ),
  _errorCB     ( 0x0 ),
  _finishedCB  ( 0x0 ),
  _startedCB   ( 0x0 ),
  _thread      ( 0x0 )
{
  USUL_TRACE_SCOPE;

  _cancelledCB = Usul::Threads::newFunctionCallback ( Usul::Adaptors::memberFunction ( this, &Job::_threadCancelled ) );
  _errorCB     = Usul::Threads::newFunctionCallback ( Usul::Adaptors::memberFunction ( this, &Job::_threadError     ) );
  _finishedCB  = Usul::Threads::newFunctionCallback ( Usul::Adaptors::memberFunction ( this, &Job::_threadFinished  ) );
  _startedCB   = Usul::Threads::newFunctionCallback ( Usul::Adaptors::memberFunction ( this, &Job::_threadStarted   ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
///////////////////////////////////////////////////////////////////////////////

Job::~Job()
{
  USUL_TRACE_SCOPE;
  Usul::Functions::safeCall ( Usul::Adaptors::memberFunction ( this, &Job::_destroy ), "3574964895" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destroy
//
///////////////////////////////////////////////////////////////////////////////

void Job::_destroy()
{
  USUL_TRACE_SCOPE;

  _cancelledCB = 0x0;
  _errorCB     = 0x0;
  _finishedCB  = 0x0;
  _startedCB   = 0x0;
  _thread      = 0x0;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Helper class to set the thread.
//
///////////////////////////////////////////////////////////////////////////////

namespace Usul
{
  namespace Jobs
  {
    namespace Helper
    {
      class ScopedThread
      {
      public:
        ScopedThread ( Job &job, Usul::Threads::Thread *thread ) : _job ( job )
        {
          _job._setThread ( thread );
        }
        ~ScopedThread()
        {
          _job._setThread ( 0x0 );
        }
      private:
        Job &_job;
      };
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Called when the thread is cancelled.
//
///////////////////////////////////////////////////////////////////////////////

void Job::_threadCancelled ( Thread *thread )
{
  USUL_TRACE_SCOPE;
  ScopedThread scoped ( *this, thread );
  this->_cancelled();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Called when the job is cancelled.
//
///////////////////////////////////////////////////////////////////////////////

void Job::_cancelled()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Called when the thread encounters an error.
//
///////////////////////////////////////////////////////////////////////////////

void Job::_threadError ( Thread *thread )
{
  USUL_TRACE_SCOPE;
  ScopedThread scoped ( *this, thread );
  this->_error();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Called when the job encounters an error.
//
///////////////////////////////////////////////////////////////////////////////

void Job::_error()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Called when the thread finishes normally.
//
///////////////////////////////////////////////////////////////////////////////

void Job::_threadFinished ( Thread *thread )
{
  USUL_TRACE_SCOPE;
  ScopedThread scoped ( *this, thread );
  this->_finished();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Called when the job finishes normally.
//
///////////////////////////////////////////////////////////////////////////////

void Job::_finished()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Called when the thread starts.
//
///////////////////////////////////////////////////////////////////////////////

void Job::_threadStarted ( Thread *thread )
{
  USUL_TRACE_SCOPE;
  ScopedThread scoped ( *this, thread );
  this->_started();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Called when the job starts.
//
///////////////////////////////////////////////////////////////////////////////

void Job::_started()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the thread.
//
///////////////////////////////////////////////////////////////////////////////

void Job::_setThread ( Thread *thread )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  _thread = thread;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Cancel this job.
//
///////////////////////////////////////////////////////////////////////////////

void Job::cancel()
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );

  if ( true == _thread.valid() )
  {
    _thread->cancel();
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return this job's id.
//
///////////////////////////////////////////////////////////////////////////////

unsigned long Job::id() const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _id;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return this job's thread, which will be null unless the job is running.
//
///////////////////////////////////////////////////////////////////////////////

const Usul::Threads::Thread *Job::thread() const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _thread.get();
}
