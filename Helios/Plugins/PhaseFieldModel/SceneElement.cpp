
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2006, Adam Kubach
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

#include "SceneElement.h"


USUL_IMPLEMENT_IUNKNOWN_MEMBERS ( SceneElement , SceneElement::BaseClass );

///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

SceneElement::SceneElement() : 
_mt( 0x0 ),
_material ( 0x0 )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

SceneElement::~SceneElement()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Query for the interface.
//
///////////////////////////////////////////////////////////////////////////////

Usul::Interfaces::IUnknown *SceneElement::queryInterface ( unsigned long iid )
{
  switch ( iid )
  {
  case Usul::Interfaces::IUnknown::IID:
  case Usul::Interfaces::ISceneElement::IID:
    return static_cast < Usul::Interfaces::ISceneElement*>(this);
  default:
    return 0x0;
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the matrix transform.
//
///////////////////////////////////////////////////////////////////////////////

void SceneElement::transform ( osg::MatrixTransform *mt )
{
  _mt = mt;
  
  osg::ref_ptr < osg::StateSet > ss ( _mt->getOrCreateStateSet() );

  osg::StateAttribute *sa ( ss->getAttribute ( osg::StateAttribute::MATERIAL ) );

  if ( osg::Material *mat = dynamic_cast < osg::Material* > ( sa ) )
    _material = mat;
  else
  {
    _material = new osg::Material;
    ss->setAttribute ( _material.get(), osg::StateAttribute::ON );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the visiblity flag.
//
///////////////////////////////////////////////////////////////////////////////

void SceneElement::setVisibility ( bool b )
{
  if ( b )
  {
    _mt->setNodeMask ( 0xffffffff );
  }
  else
  {
    _mt->setNodeMask ( 0 );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the visiblity flag.
//
///////////////////////////////////////////////////////////////////////////////

bool SceneElement::getVisibility ( ) const
{
  return _mt->getNodeMask (  ) != 0;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the translation.
//
///////////////////////////////////////////////////////////////////////////////

void SceneElement::setTranslation ( const osg::Vec3f& translate )
{
  osg::Matrix m ( _mt->getMatrix() );
  m.setTrans ( translate );
  _mt->setMatrix ( m );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the translation.
//
///////////////////////////////////////////////////////////////////////////////

osg::Vec3f SceneElement::getTranslation ( ) const
{
  osg::Matrix m ( _mt->getMatrix() );
  return m.getTrans();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the rotation.
//
///////////////////////////////////////////////////////////////////////////////

void SceneElement::setRotation ( const osg::Quat& rotation )
{
  osg::Matrix m;
  m.setTrans ( _mt->getMatrix().getTrans() );
  m.makeRotate ( rotation );
  _mt->setMatrix ( m );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the rotation.
//
///////////////////////////////////////////////////////////////////////////////

osg::Quat SceneElement::getRotation ( ) const
{
  osg::Matrix m ( _mt->getMatrix() );
  osg::Quat q;
  m.get( q );
  return q;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the diffuse color.
//
///////////////////////////////////////////////////////////////////////////////

void SceneElement::setDiffuseColor ( const osg::Vec4f& diffuse )
{
  _material->setDiffuse( osg::Material::FRONT_AND_BACK, diffuse );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the diffuse color.
//
///////////////////////////////////////////////////////////////////////////////

const osg::Vec4f& SceneElement::getDiffuseColor ( ) const
{
  return _material->getDiffuse( osg::Material::FRONT_AND_BACK );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the specular color.
//
///////////////////////////////////////////////////////////////////////////////

void SceneElement::setSpecularColor ( const osg::Vec4f& specular )
{
  _material->setSpecular ( osg::Material::FRONT_AND_BACK, specular );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the specular color.
//
///////////////////////////////////////////////////////////////////////////////

const osg::Vec4f& SceneElement::getSpecularColor () const
{
  return _material->getSpecular ( osg::Material::FRONT_AND_BACK );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the shininess value.
//
///////////////////////////////////////////////////////////////////////////////

void SceneElement::setShininess( float s )
{
  _material->setShininess( osg::Material::FRONT_AND_BACK, s );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the shininess value.
//
///////////////////////////////////////////////////////////////////////////////

float SceneElement::getShininess() const
{
  return _material->getShininess( osg::Material::FRONT_AND_BACK );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the transparency value.
//
///////////////////////////////////////////////////////////////////////////////

void SceneElement::setTransparency ( float t )
{
  _material->setTransparency ( osg::Material::FRONT_AND_BACK, t );

  osg::ref_ptr< osg::StateSet > ss ( _mt->getOrCreateStateSet() );

  if ( t == 1.0 )
  {
    ss->setMode ( GL_BLEND,      osg::StateAttribute::OFF );
    ss->setMode ( GL_DEPTH_TEST, osg::StateAttribute::ON  );
    ss->setRenderingHint( osg::StateSet::DEFAULT_BIN );
  }
  else
  {
    ss->setMode ( GL_BLEND,      osg::StateAttribute::ON  );
    ss->setMode ( GL_DEPTH_TEST, osg::StateAttribute::OFF );
    ss->setRenderingHint( osg::StateSet::TRANSPARENT_BIN );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the transparency value.
//
///////////////////////////////////////////////////////////////////////////////

float SceneElement::getTransparency () const
{
  //float ta ( _material->getAmbient( osg::Material::FRONT_AND_BACK ).w() );
  float td ( _material->getDiffuse( osg::Material::FRONT_AND_BACK ).w() );
  //float ts ( _material->getSpecular( osg::Material::FRONT_AND_BACK ).w() );
  //float te ( _material->getEmissive( osg::Material::FRONT_AND_BACK ).w() );

  return td;
}
