
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Thread manager classes.
//
///////////////////////////////////////////////////////////////////////////////

#include "Usul/Threads/Manager.h"
#include "Usul/Errors/Assert.h"
#include "Usul/Threads/ThreadId.h"
#include "Usul/Trace/Trace.h"

#include <stdexcept>

using namespace Usul::Threads;


///////////////////////////////////////////////////////////////////////////////
//
//  Static data members.
//
///////////////////////////////////////////////////////////////////////////////

Manager *Manager::_instance ( 0x0 );


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Manager::Manager() :
  _mutex          (),
  _factory        ( 0x0 ),
  _guiThread      ( 0 ),
  _nextThreadId   ( 0 )
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Manager::~Manager()
{
  USUL_TRACE_SCOPE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Singleton construction.
//
///////////////////////////////////////////////////////////////////////////////

Manager &Manager::instance()
{
  USUL_TRACE_SCOPE_STATIC;
  if ( 0x0 == _instance )
  {
    _instance = new Manager;
  }
  return *_instance;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Create the thread. Client needs to set the function.
//
///////////////////////////////////////////////////////////////////////////////

Usul::Threads::Thread *Manager::create()
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );

  if ( 0x0 == _factory )
  {
    USUL_ASSERT ( _factory ); // The client needs to set this.
    throw std::runtime_error ( "Error 2149832182: No thread factory set" );
  }

  return (*_factory)();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the factory-function. Return the previous one.
//
///////////////////////////////////////////////////////////////////////////////

Manager::FactoryFunction *Manager::factory ( Manager::FactoryFunction *factory )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );

  FactoryFunction *original = _factory;
  _factory = factory;
  return original;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the factory-function.
//
///////////////////////////////////////////////////////////////////////////////

Manager::FactoryFunction *Manager::factory()
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _factory;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the GUI thread ID.
//
///////////////////////////////////////////////////////////////////////////////

void Manager::guiThread ( unsigned long id )
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  _guiThread = id;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the GUI thread ID.
//
///////////////////////////////////////////////////////////////////////////////

unsigned long Manager::guiThread() const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  return _guiThread;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Is this the GUI thread?
//
///////////////////////////////////////////////////////////////////////////////

bool Manager::isGuiThread() const
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  const unsigned long id ( Usul::Threads::currentThreadId() );
  return ( id == _guiThread );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Return the mutex. Use with caution.
//
///////////////////////////////////////////////////////////////////////////////

Manager::Mutex &Manager::mutex() const
{
  USUL_TRACE_SCOPE;
  return _mutex;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the next thread id. This will also increment the internal counter.
//
///////////////////////////////////////////////////////////////////////////////

unsigned long Manager::nextThreadId()
{
  USUL_TRACE_SCOPE;
  Guard guard ( this->mutex() );
  unsigned long id ( _nextThreadId++ );
  return id;
}
