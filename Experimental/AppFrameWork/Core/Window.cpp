
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  Base class for all windows.
//
///////////////////////////////////////////////////////////////////////////////

#include "AppFrameWork/Core/Group.h"
#include "AppFrameWork/Core/Application.h"
#include "AppFrameWork/Core/BaseVisitor.h"
#include "AppFrameWork/Core/Define.h"

#include "Usul/Bits/Bits.h"
#include "Usul/Errors/Assert.h"
#include "Usul/MPL/SameType.h"

#include <iostream>
#include <stdexcept>

using namespace AFW::Core;


///////////////////////////////////////////////////////////////////////////////
//
//  Static data member(s).
//
///////////////////////////////////////////////////////////////////////////////

Window::WindowList Window::_allWindows;


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Window::Window ( const std::string &text, Icon *icon ) : BaseClass(),
  _whichWindow ( _allWindows.end() ),
  _flags       ( State::DIRTY ),
  _parent      ( 0x0 ),
  _icon        ( icon ),
  _text        ( text ),
  _title       (),
  _commands    (),
  _updates     (),
  _percent     ( 100.0f, 100.0f ),
  _guiObject   (),
  _dockState   ( AFW::Core::DockSite::NONE, 0 ),
  _devices     ()
{
  typedef std::list < Window::ValidRefPtr > ListOfWindows;
  typedef std::iterator_traits < Window::WindowList::iterator > Traits1;
  typedef std::iterator_traits < ListOfWindows::iterator > Traits2;
  typedef Traits1::iterator_category Category1;
  typedef Traits2::iterator_category Category2;
  USUL_ASSERT_SAME_TYPE ( Category1, Category2 );

  // Relies on the fact that list iterators are not invalidated.
  _whichWindow = _allWindows.insert ( _allWindows.end(), this );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Window::~Window()
{
  // Safely...
  try
  {
    USUL_ASSERT ( false == _allWindows.empty() );

    // Relies on the fact that list iterators are not invalidated.
    _allWindows.erase ( _whichWindow );

    // The parent is now dirty.
    if ( _parent )
      _parent->dirty ( true );

    // Tell the application that we are being destroyed.
    Application::instance().destroyNotify ( this );
  }

  // Catch exceptions.
  AFW_CATCH_BLOCK ( "3539223479", "3180678094" );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the dirty flag.
//
///////////////////////////////////////////////////////////////////////////////

void Window::dirty ( bool state )
{
  const unsigned int bit ( State::DIRTY );
  if ( state )
  {
    _flags = Usul::Bits::add ( _flags, bit );

    // Set parent as dirty too.
    if ( _parent )
      _parent->dirty ( true );
  }
  else
  {
    _flags = Usul::Bits::remove ( _flags, bit );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the dirty flag.
//
///////////////////////////////////////////////////////////////////////////////

bool Window::dirty() const
{
  const unsigned int bit ( State::DIRTY );
  return Usul::Bits::has ( _flags, bit );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the parent.
//
///////////////////////////////////////////////////////////////////////////////

const Group *Window::parent() const
{
  return _parent;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the parent.
//
///////////////////////////////////////////////////////////////////////////////

Group *Window::parent()
{
  return _parent;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the text.
//
///////////////////////////////////////////////////////////////////////////////

std::string Window::textGet() const
{
  return _text;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the text.
//
///////////////////////////////////////////////////////////////////////////////

void Window::textGet ( std::string &s ) const
{
  s = _text;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the text.
//
///////////////////////////////////////////////////////////////////////////////

void Window::textSet ( const std::string &t )
{
  _text = t;
  this->dirty ( true );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the text.
//
///////////////////////////////////////////////////////////////////////////////

void Window::textSet ( const char *t, unsigned int length )
{
  if ( t )
  {
    _text.assign ( t, t + length );
    this->dirty ( true );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append the text.
//
///////////////////////////////////////////////////////////////////////////////

void Window::textAppend ( const std::string &t )
{
  _text += t;
  this->dirty ( true );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append the text.
//
///////////////////////////////////////////////////////////////////////////////

void Window::textAppend ( const char *t, unsigned int length )
{
  if ( t )
  {
    _text.insert ( _text.end(), t, t + length );
    this->dirty ( true );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the title.
//
///////////////////////////////////////////////////////////////////////////////

const std::string &Window::title() const
{
  return _title;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the title.
//
///////////////////////////////////////////////////////////////////////////////

void Window::title ( const std::string &t )
{
  _title = t;
  this->dirty ( true );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append an action.
//
///////////////////////////////////////////////////////////////////////////////

void Window::append ( AFW::Actions::CommandAction *c )
{
  if ( c )
    _commands.push_back ( c );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append an action.
//
///////////////////////////////////////////////////////////////////////////////

void Window::append ( AFW::Conditions::Condition *c, AFW::Actions::UpdateAction *u )
{
  if ( c && u )
    _updates.push_back ( UpdatePair ( c, u ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Append a device.
//
///////////////////////////////////////////////////////////////////////////////

void Window::append ( BaseDevice *d )
{
  if ( d )
    _devices.push_back ( d );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the parent.
//
///////////////////////////////////////////////////////////////////////////////

void Window::_setParent ( Group *parent )
{
  _parent = parent;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the icon.
//
///////////////////////////////////////////////////////////////////////////////

const AFW::Core::Icon *Window::icon() const
{
  return _icon.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the icon.
//
///////////////////////////////////////////////////////////////////////////////

AFW::Core::Icon *Window::icon()
{
  return _icon.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the icon.
//
///////////////////////////////////////////////////////////////////////////////

void Window::icon ( AFW::Core::Icon *i )
{
  _icon = i;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::CommandActionsItr Window::commandsBegin()
{
  return _commands.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::CommandActionsConstItr Window::commandsBegin() const
{
  return _commands.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::CommandActionsItr Window::commandsEnd()
{
  return _commands.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::CommandActionsConstItr Window::commandsEnd() const
{
  return _commands.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::UpdatePairsItr Window::updatesBegin()
{
  return _updates.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::UpdatePairsConstItr Window::updatesBegin() const
{
  return _updates.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::UpdatePairsItr Window::updatesEnd()
{
  return _updates.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::UpdatePairsConstItr Window::updatesEnd() const
{
  return _updates.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::DevicesItr Window::devicesBegin()
{
  return _devices.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::DevicesConstItr Window::devicesBegin() const
{
  return _devices.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the actions.
//
///////////////////////////////////////////////////////////////////////////////

Window::DevicesItr Window::devicesEnd()
{
  return _devices.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterators to the devices.
//
///////////////////////////////////////////////////////////////////////////////

Window::DevicesConstItr Window::devicesEnd() const
{
  return _devices.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Call the actions.
//
///////////////////////////////////////////////////////////////////////////////

void Window::callCommandActions()
{
  for ( CommandActionsItr i = _commands.begin(); i != _commands.end(); ++i )
  {
    CommandAction::RefPtr command ( *i );
    if ( command.valid() )
    {
      command->execute ( this );
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Call the actions.
//
///////////////////////////////////////////////////////////////////////////////

void Window::callUpdateActions()
{
  for ( UpdatePairsItr i = _updates.begin(); i != _updates.end(); ++i )
  {
    UpdatePair update ( *i );
    AFW::Conditions::Condition::RefPtr condition ( update.first );
    AFW::Actions::UpdateAction::RefPtr action ( update.second );
    if ( condition.valid() && action.valid() )
    {
      if ( condition->evaluate ( this ) )
        action->execute ( this );
    }
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the docked state.
//
///////////////////////////////////////////////////////////////////////////////

void Window::dockState ( DockState state )
{
  // Handle unchanged case.
  if ( this->dockState() == state )
    return;

  // Set the flag.
  _dockState = state;

  // We are dirty.
  this->dirty ( true );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the docked state.
//
///////////////////////////////////////////////////////////////////////////////

Window::DockState Window::dockState() const
{
  return _dockState;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the percent.
//
///////////////////////////////////////////////////////////////////////////////

void Window::percent ( const Usul::Math::Vec2f &p )
{
  _percent = p;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the percent.
//
///////////////////////////////////////////////////////////////////////////////

void Window::percent ( float x, float y )
{
  _percent.set ( x, y );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the percent.
//
///////////////////////////////////////////////////////////////////////////////

Usul::Math::Vec2f Window::percent() const
{
  return _percent;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterator to the list of all windows.
//
///////////////////////////////////////////////////////////////////////////////

Window::WindowListItr Window::allWindowsBegin()
{
  return _allWindows.begin();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Iterator to the list of all windows.
//
///////////////////////////////////////////////////////////////////////////////

Window::WindowListItr Window::allWindowsEnd()
{
  return _allWindows.end();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Accept the visitor.
//
///////////////////////////////////////////////////////////////////////////////

void Window::accept ( AFW::Core::BaseVisitor *v )
{
  if ( v )
    v->visit ( this );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the gui-object.
//
///////////////////////////////////////////////////////////////////////////////

const Window::GuiObject *Window::guiObject() const
{
  return _guiObject.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the user-data.
//
///////////////////////////////////////////////////////////////////////////////

Window::GuiObject *Window::guiObject()
{
  return _guiObject.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the user-data.
//
///////////////////////////////////////////////////////////////////////////////

void Window::guiObject ( Window::GuiObject *object )
{
  _guiObject = object;
}


///////////////////////////////////////////////////////////////////////////////
//
//  This function is plumbing for the visitor pattern.
//
///////////////////////////////////////////////////////////////////////////////

void Window::_traverse ( AFW::Core::BaseVisitor * )
{
}
