
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002, Perry L. Miller IV
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// 
//  An interactive viewer class.
//
///////////////////////////////////////////////////////////////////////////////

#include "GSG/Core/Precompiled.h"
#include "GSG/Core/Viewer.h"
#include "GSG/Core/Bits.h"

using namespace GSG;

GSG_IMPLEMENT_REFERENCED ( Viewer );


///////////////////////////////////////////////////////////////////////////////
//
//  Bits for "_flags". I don't want these in a header file.
//
///////////////////////////////////////////////////////////////////////////////

namespace GSG
{
  namespace Detail
  {
    const UnsignedInteger MOUSE_POINT_UNSET  = 0x00000001;
  };
};


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Viewer::Viewer() : Referenced(),
  _flags       ( Detail::MOUSE_POINT_UNSET ),
  _scene       ( 0x0 ), 
  _renderer    ( 0x0 ),
  _camera      ( new Camera ),
  _keys        ( new Keys ),
  _windowMouse ( 0, 0 ),
  _lastMouse   ( 0, 0 ),
  _callback    ( 0x0 ),
  _dR          ()
{
  ErrorChecker ( _camera.valid() );
  ErrorChecker ( _keys.valid() );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Copy constructor. 
//
//  Note: I could clone the scene, renderer, etc. But if the user wants the 
//  new viewer to share the original's pointer-members, then he/she will 
//  have to wait for the copy (and the scene may be big) and then replace it 
//  with the original viewer's scene, renderer, etc. It is better to copy this
//  fast way, and then let the user make clones where desired.
//
///////////////////////////////////////////////////////////////////////////////

Viewer::Viewer ( const Viewer &v ) : Referenced ( v ),
  _flags       ( v._flags | Detail::MOUSE_POINT_UNSET ),
  _scene       ( v._scene ), 
  _renderer    ( v._renderer ),
  _camera      ( v._camera ),
  _keys        ( v._keys ),
  _windowMouse ( v._windowMouse ),
  _lastMouse   ( v._lastMouse ),
  _callback    ( v._callback ),
  _dR          ( v._dR )
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Viewer::~Viewer()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor for callback class.
//
///////////////////////////////////////////////////////////////////////////////

Viewer::Callback::~Callback()
{
}


/////////////////////////////////////////////////////////////////////////////
//
//  Set from the given object.
//
/////////////////////////////////////////////////////////////////////////////

void Viewer::setFrom ( const Viewer &v )
{
  Lock lock ( this );

  // Set the members.
  _flags       = v._flags | Detail::MOUSE_POINT_UNSET;
  _scene       = v._scene;
  _renderer    = v._renderer;
  _camera      = v._camera;
  _keys        = v._keys;
  _windowMouse = v._windowMouse;
  _lastMouse   = v._lastMouse;
  _callback    = v._callback;
  _dR          = v._dR;

  // Call the base class's function.
  BaseClass::setFrom ( v );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Call this function when the mouse moves.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::mouseMoved ( SignedInteger x, SignedInteger y, UnsignedInteger buttonsDown )
{
  Lock lock ( this );

  // The first time in here we have to do this.
  if ( GSG::hasBits ( _flags, Detail::MOUSE_POINT_UNSET ) )
  {
    _windowMouse.set ( x, y );
    _flags = GSG::removeBits ( _flags, Detail::MOUSE_POINT_UNSET );
  }

  // Save the new mouse point.
  _lastMouse = _windowMouse;
  _windowMouse.set ( x, y );

  // If the current and last mouse position are the same then return.
  if ( _windowMouse.equal ( _lastMouse ) ) 
    return;

  // TODO
}


///////////////////////////////////////////////////////////////////////////////
//
//  Call this function when the mouse button is pressed.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::mouseButtonDown ( SignedInteger x, SignedInteger y, 
                               UnsignedInteger whichButtonDown, 
                               UnsignedInteger buttonsDown )
{
  Lock lock ( this );
  // TODO
}


///////////////////////////////////////////////////////////////////////////////
//
//  Call this function when the mouse button is released.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::mouseButtonUp ( SignedInteger x, SignedInteger y, UnsignedInteger whichButtonUp, UnsignedInteger buttonsDown )
{
  Lock lock ( this );
  // TODO
}


///////////////////////////////////////////////////////////////////////////////
//
//  This gets called when the user resizes the window.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::resize ( UnsignedInteger width, UnsignedInteger height ) 
{
  Lock lock ( this );

  // If we have a renderer...
  if ( _renderer.valid() )
  {
    // Set the viewport.
    _renderer->viewport ( Viewport ( 0, 0, width, height ) );
  }

  // If we have a camera...
  if ( _camera.valid() )
  {
    // Set the aspect ratio.
    _camera->aspectRatio ( static_cast<Real>(width) / static_cast<Real>(height) );
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Small helper class to attach and detach the scene from the camera.
//
///////////////////////////////////////////////////////////////////////////////

namespace GSG
{
  namespace Detail
  {
    struct AttachAndRemove
    {
      AttachAndRemove ( Camera *p, Node *n ) : _p ( p )
      {
        _p->clear();
        _p->append ( n );
      }
      ~AttachAndRemove()
      {
        _p->clear();
      }
    private:
      Camera::ValidPtr _p;
    };
  };
};


///////////////////////////////////////////////////////////////////////////////
//
//  This will draw everything connected to the scene.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::render()
{
  Lock lock ( this );

  // If there is a camera, renderer, and a scene...
  if ( _camera.valid() && _renderer.valid() && _scene.valid() )
  {
    // This will temporarily attach the scene to the camera.
    Detail::AttachAndRemove temp ( _camera, _scene );

    // Render the camera.
    _renderer->traverse ( *_camera );

    // Reset the renderer.
    _renderer->reset(); // TODO, make this exception-safe.
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Move the camera so that the whole scene is visible.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::viewAll()
{
  Lock lock ( this );
  ErrorChecker ( _camera.valid() );
  _camera->viewAll();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Call this when a key is pressed when the mouse is over the window.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::keyDown ( UnsignedInteger c )
{
  Lock lock ( this );
  _keys->down ( c );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Call this when a key is released when the mouse is over the window.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::keyUp ( UnsignedInteger c ) 
{
  Lock lock ( this );
  _keys->up ( c );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the scene.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::scene ( Node *scene ) 
{
  Lock lock ( this );
  _scene = scene;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the scene.
//
///////////////////////////////////////////////////////////////////////////////

const Node *Viewer::scene() const
{
  Lock lock ( this );
  return _scene.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the scene.
//
///////////////////////////////////////////////////////////////////////////////

Node *Viewer::scene()
{
  Lock lock ( this );
  return _scene.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the camera.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::camera ( Camera *camera ) 
{
  Lock lock ( this );
  _camera = camera;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the scene.
//
///////////////////////////////////////////////////////////////////////////////

const Camera *Viewer::camera() const
{
  Lock lock ( this );
  return _camera.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the scene.
//
///////////////////////////////////////////////////////////////////////////////

Camera *Viewer::camera()
{
  Lock lock ( this );
  return _camera.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the renderer.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::renderer ( Renderer *renderer ) 
{
  Lock lock ( this );
  _renderer = renderer;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the renderer.
//
///////////////////////////////////////////////////////////////////////////////

const Renderer *Viewer::renderer() const
{
  Lock lock ( this );
  return _renderer.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the renderer.
//
///////////////////////////////////////////////////////////////////////////////

Renderer *Viewer::renderer()
{
  Lock lock ( this );
  return _renderer.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the callback.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::callback ( Viewer::Callback *callback ) 
{
  Lock lock ( this );
  _callback = callback;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the renderer.
//
///////////////////////////////////////////////////////////////////////////////

const Viewer::Callback *Viewer::callback() const
{
  Lock lock ( this );
  return _callback.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the renderer.
//
///////////////////////////////////////////////////////////////////////////////

Viewer::Callback *Viewer::callback()
{
  Lock lock ( this );
  return _callback.get();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Tell the viewer that is should spin the geometry. Typically this 
//  function is called from within a timer callback.
//
///////////////////////////////////////////////////////////////////////////////

void Viewer::spinNotify()
{
  Lock lock ( this );

  // If there is a camera then rotate it.
  if ( _camera.valid() )
    _camera->rotate ( _dR );
}
